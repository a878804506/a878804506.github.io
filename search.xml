<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker数据卷技术</title>
      <link href="/2021/05/25/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8A%80%E6%9C%AF/"/>
      <url>/2021/05/25/Docker%E6%95%B0%E6%8D%AE%E5%8D%B7%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇侧重点"><a href="#一、本篇侧重点" class="headerlink" title="一、本篇侧重点"></a>一、本篇侧重点</h3><blockquote><ol><li>数据卷容器</li><li>Docker的具名挂载、匿名挂载、指定路径挂载</li><li>Dockerfile</li><li>Dockerfile指令说明</li><li>实战：Dockerfile构建带http-flv模块的nginx镜像</li></ol></blockquote><h3 id="二、数据卷容器"><a href="#二、数据卷容器" class="headerlink" title="二、数据卷容器"></a>二、数据卷容器</h3><ol><li>话不多说先上图！</li></ol><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.1.png" align="left/"><p>​    就是将服务器上的某个文件夹的绝对路径与Docker实例上某个路径做映射，挂载到实例上，这样实例就能访问服务器的真实文件夹，总结一句话：容器的持久化和同步操作！容器间是可以数据共享。</p><ol start="2"><li>挂载命令：-v， –volume</li></ol><pre class=" language-shell"><code class="language-shell">docker run -it -v 主机目录:容器内目录  -p 主机端口:容器内端口 镜像名称</code></pre><p>提前准备好一个nginx.conf文件，放到这个文件夹<strong>/usr/local/docker/nginx/conf</strong>：</p><pre class=" language-conf"><code class="language-conf">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;events {    worker_connections  1024;}http {    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '                    '$status $body_bytes_sent "$http_referer" '                    '"$http_user_agent" "$http_x_forwarded_for"';    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    server {    listen       80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;    location / {        root   /usr/share/nginx/html;        index  index.html index.htm;    }    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   /usr/share/nginx/html;    }  }}</code></pre><p>启动一个nginx，并挂载目录<strong>/usr/local/docker/nginx/conf</strong></p><pre class=" language-shell"><code class="language-shell">docker run -it --name mynginx -v /usr/local/docker/nginx/conf:/etc/nginx/ -p 8001:80 nginx# 进入容器docker exec -it f4e5cdcc3576 /bin/bash</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.2.png" align="left/"><p>可以看到文件已经挂载上来了，然后在服务器上添加一个文件加入内容，再到docker实例内部查看：</p><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.3.png" align="left/"><ol start="3"><li>使用 docker inspect 容器id 查看详情：</li></ol><pre class=" language-shell"><code class="language-shell">docker inspect f4e5cdcc3576</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.4.png" align="left/"><p>上图中 Mounts 便是这个容器的挂载配置，注：它是一个数组，可以同时挂载多个目录！</p><h3 id="三、Docker的具名、匿名、指定路径挂载"><a href="#三、Docker的具名、匿名、指定路径挂载" class="headerlink" title="三、Docker的具名、匿名、指定路径挂载"></a>三、Docker的具名、匿名、指定路径挂载</h3><ol><li>匿名挂载</li></ol><pre class=" language-shell"><code class="language-shell"># -v 容器内路径docker run -d -P --name mynginx1 -v /etc/nginx nginx# 查看所有的volume的情况docker volume ls</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.5.png" align="left/"><p>这种就是匿名挂载，不指定宿主机的任何路径</p><pre class=" language-shell"><code class="language-shell"># 使用命令查看容器的匿名挂载情况docker volume inspect 6f743944485ff33375f3a0699c3a0c90da3273b8c48826e33f1ab134e25a3e4e</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.6.png" align="left/"><p><strong>匿名挂载时，Docker会在宿主机固定目录为容器挂载一个目录，根目录在：/var/lib/docker/volumes/ 下，然后 加上容器id/_data  这个目录就是容器的数据目录</strong></p><ol start="2"><li>具名挂载</li></ol><pre class=" language-shell"><code class="language-shell"># -v 名字:容器内路径docker run -d -P --name mynginx1 -v/etc/nginx nginx# 使用命令查看挂载情况docker volume inspect juming_nginx</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.7.png" align="left/"><p>所有的docker容器内的卷，没有指定目录的情况下都是在 <strong>/var/lib/docker/volumes/xxxx/_data</strong>下！</p><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/2.8.png" align="left/"><ol start="3"><li>指定路径挂载</li></ol><p><strong>-v /宿主机路径：容器内路径 <em>#指定路径挂载 docker volume ls 是查看不到的</em></strong></p><ol start="4"><li>拓展</li></ol><pre class=" language-shell"><code class="language-shell"># 通过 -v 容器内路径： ro rw 改变读写权限# ro #readonly 只读# rw #readwrite 可读可写docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginxdocker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx# ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</code></pre><h3 id="四、Dockerfile"><a href="#四、Dockerfile" class="headerlink" title="四、Dockerfile"></a>四、Dockerfile</h3><p><strong>Dockerfile 就是用来构建docker镜像的构建文件</strong>！命令脚本！</p><p>通过这个<strong>脚本可以生成镜像</strong>，镜像是一层一层的，脚本是一个个的命令，每个命令都是一层！</p><p>构建步骤：</p><ol><li><p>编写一个dockerfile文件</p></li><li><p>docker build 构建称为一个镜像</p></li><li><p>docker run运行镜像</p></li><li><p>docker push发布镜像（DockerHub 、阿里云仓库)</p></li></ol><p><strong>DockerFile的构建过程</strong></p><p>基础知识：</p><ol><li><p>每个保留关键字(指令）都是必须是大写字母</p></li><li><p>执行从上到下顺序</p></li><li><p>#表示注释</p></li><li><p>每一个指令都会创建提交一个新的镜像曾，并提交！</p></li></ol><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/4.1.png" align="left/"><p>Dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件！</p><p>DockerFile：构建文件，定义了一切的步骤，源代码</p><p>DockerImages：通过DockerFile构建生成的镜像，最终发布和运行产品。</p><p>Docker容器：容器就是镜像运行起来提供服务。</p><h3 id="五、Dockerfile指令说明"><a href="#五、Dockerfile指令说明" class="headerlink" title="五、Dockerfile指令说明"></a>五、Dockerfile指令说明</h3><pre class=" language-shell"><code class="language-shell">FROM                # from:基础镜像，一切从这里开始构建MAINTAINER            # maintainer:镜像是谁写的， 姓名+邮箱RUN                    # run:镜像构建的时候需要运行的命令ADD                    # add:步骤，tomcat镜像，这个tomcat压缩包！添加内容 添加同目录WORKDIR                # workdir:镜像的工作目录VOLUME                # volume:挂载的目录EXPOSE                # expose:保留端口配置CMD                    # cmd:指定这个容器启动的时候要运行的命令，只有最后一个会生效，可被替代ENTRYPOINT            # entrypoint:指定这个容器启动的时候要运行的命令，可以追加命令ONBUILD                # onbuild:当构建一个被继承DockerFile这个时候就会运行onbuild的指令，触发指令COPY                # copy:类似ADD，将我们文件拷贝到镜像中ENV                    # env:构建的时候设置环境变量！</code></pre><h3 id="六、-实战：Dockerfile构建带http-flv模块的nginx镜像"><a href="#六、-实战：Dockerfile构建带http-flv模块的nginx镜像" class="headerlink" title="六、   实战：Dockerfile构建带http-flv模块的nginx镜像"></a>六、   实战：Dockerfile构建带http-flv模块的nginx镜像</h3><blockquote><p>现在公司产品需求需要做视频监控功能，也是第一次做，真的是一边踩坑一边收资料然后还要狂补H5播放、码流转码，流服务器这一类的知识，真的是太难了！用nginx也可以做流媒体服务器，但是它需要继承一个第三方模块http-flv，docker里面又只提供了基础的nginx镜像，无法满足，决定手动编译一个带http-flv模块的nginx，然后打包成docker镜像！</p></blockquote><p>话不多说开始撸起来！</p><p>首选准备nginx源码包、http-flv模块的源码包（github上可下载），解压！</p><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/6.1.png" align="left/"><pre class=" language-shell"><code class="language-shell"># 进入到nginx1.18目录下，对nginx进行编译bash configure --prefix=/usr/local/nginx --sbin-path=/usr/local/nginx/sbin/nginx --conf-path=/usr/local/nginx/conf/nginx.conf --error-log-path=/usr/local/nginx/logs/error.log --http-log-path=/usr/local/nginx/logs/access.log --pid-path=/usr/local/nginx/logs/nginx.pid --lock-path=/usr/local/nginx/lock/nginx.lock --user=root --group=root --with-http_ssl_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module  --with-debug --http-client-body-temp-path=/usr/local/nginx/temp --with-stream --without-http_rewrite_module# 编译make# 输出文件make install</code></pre><p><strong>/usr/local/nginx 此目录就是编译后的nginx目录</strong></p><pre class=" language-shell"><code class="language-shell"># 切换到 /usr/local 目录 编写一个dockerfile，内容如下：FROM centosMAINTAINER cyhWORKDIR /usr/local# 将宿主机当前目录下的nginx 复制到 镜像内的/usr/local/nginx/下COPY nginx /usr/local/nginx/CMD ["/usr/local/nginx/sbin/nginx","-g","daemon off;"]</code></pre><pre class=" language-shell"><code class="language-shell"># 使用命令创建镜像  不要忘记后面的点！！！# -f 可指定dockerfile文件# -t 镜像名docker build -t nginx_stream .</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/6.2.png" align="left/"><pre class=" language-shell"><code class="language-shell"># 导出镜像成一个tar文件docker save -o nginx_stream.tar nginx_stream:1.0# 为什么要导出成文件，因为我是在家里制作的镜像文件呀，等周一带到公司就可以部署了！啊哈哈哈哈哈</code></pre><p>启动docker镜像成一个容器！</p><pre class=" language-shell"><code class="language-shell">docker run -d --name nginx_stream -p 8081:80 -v /usr/local/nginx/conf:/usr/local/nginx/conf -v /usr/local/nginx/html:/usr/local/nginx/html -v /usr/local/nginx/logs:/usr/local/nginx/logs nginx_stream:1.0 # 这里挂载了3个目录 分别是配置文件目录，静态文件目录和日志目录，方便配置和管理！</code></pre><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/6.3.png" align="left/"><p>接下来咱们修改宿主机<strong>/usr/local/nginx/html/index.html</strong>文件，将title标题改成<strong>hello！http-flv</strong>！然后重启docker容器，在访问8081，看看挂载是否成功！</p><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20210524/6.4.png" align="left/"><p><strong><font color="green">在贴一份作为流媒体服务器的nginx.conf的配置，日后写视频监控的记录时会用到！</font></strong></p><pre class=" language-shell"><code class="language-shell">worker_processes  1;error_log  logs/error.log info;events {    worker_connections  1024;}rtmp {    server {        listen 1935;        application live {            live on;            hls on;             hls_path temp/hls;            hls_fragment 1s;            hls_cleanup on;            hls_playlist_length 1s;        }        application hls {            live on;            hls on;             hls_fragment 8s;        }    }}http {    include    mime.types;    default_type    application/octet-stream;    sendfile on;    keepalive_timeout 65;    access_log off;    server {        listen 20000;        server_name localhost;        location / {            root html;            index index.html index.htm;        }        #为了能访问到hls流协议新增：        location /hls {            types{                applictaion/vnd.apple.mpegurl m3u8;                video/mp2t ts;            }            root html;            add_header Cache-Control no-cache;            add_header Access-Control-Allow-Origin *;        }        location /live {            flv_live on;            chunked_transfer_encoding  on; #open 'Transfer-Encoding: chunked' response            add_header 'Access-Control-Allow-Credentials' 'true'; #add additional HTTP header            add_header 'Access-Control-Allow-Origin' '*'; #add additional HTTP header            add_header Access-Control-Allow-Headers X-Requested-With;            add_header Access-Control-Allow-Methods GET,POST,OPTIONS;            add_header 'Cache-Control' 'no-cache';        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器化 </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门</title>
      <link href="/2021/04/29/Docker%E5%85%A5%E9%97%A8/"/>
      <url>/2021/04/29/Docker%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇侧重点"><a href="#一、本篇侧重点" class="headerlink" title="一、本篇侧重点"></a>一、本篇侧重点</h3><blockquote><ol><li>Docker概念</li><li>安装Docker</li><li>Docker的常用命令</li><li>联合文件系统</li></ol></blockquote><h3 id="二、Docker概念"><a href="#二、Docker概念" class="headerlink" title="二、Docker概念"></a>二、Docker概念</h3><p>Docker作为容器化技术有头有脸的存在，至今还没有开始系统学习真的惭愧惭愧，这次我要把docker系统的撸一遍！</p><p>话不多说先上一个官方图：</p><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/0.png" alt="0" style="width:85%;height:85%;"><p><strong>镜像（image)：</strong></p><p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==&gt;run==&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p><p><strong>容器(container)：</strong></p><p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p><p><strong>仓库(repository)：</strong></p><p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p><h3 id="三、安装Docker"><a href="#三、安装Docker" class="headerlink" title="三、安装Docker"></a>三、安装Docker</h3><blockquote><p>环境准备</p></blockquote><p>我的机器是Centos 7.9，内核版本3.10</p><pre class=" language-shell"><code class="language-shell">[root@i-nzuy9eqo etc]# uname -r3.10.0-957.27.2.el7.x86_64[root@i-nzuy9eqo etc]# cat /etc/redhat-releaseCentOS Linux release 7.9.2009 (Core)</code></pre><pre class=" language-shell"><code class="language-shell"># 先设置一下国内的docker镜像仓库yum-config-manager  --add-repo  https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></pre><pre class=" language-shell"><code class="language-shell"># 再更新一下yum仓库yum update -y# 查看仓库里面的dockeryum list docker-ce</code></pre><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/1.png" alt="1" style="width:85%;height:85%;"><pre class=" language-shell"><code class="language-shell"># 安装指定版本yum install docker-ce-20.10.6-3.el7 docker-ce-cli-20.10.6-3.el7 containerd.io# 启动dockersystemctl start docker# 停止dockersystemctl stop docker# 查看docker状态systemctl status docker# 使用docker version查看是否按照成功docker version# 测试docker run hello-world#查看docker镜像docker iamges</code></pre><p>卸载docker</p><pre class=" language-shell"><code class="language-shell">#1. 卸载依赖yum remove docker-ce docker-ce-cli containerd.io#2. 删除资源rm -rf /var/lib/docker# /var/lib/docker 是docker的默认工作路径！</code></pre><p>使用命令 <code>docker run hello-world</code>启动容器的流程说明：</p><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/3.png" alt="3" style="width:85%;height:85%;"><p><strong>docker run 流程图</strong></p><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/2.png" alt="2" style="width:85%;height:85%;"><p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p><p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p><h3 id="四、Docker的常用命令"><a href="#四、Docker的常用命令" class="headerlink" title="四、Docker的常用命令"></a>四、Docker的常用命令</h3><ol><li><p>帮助命令</p><pre class=" language-shell"><code class="language-shell">docker version    # 显示docker的版本信息。docker info       # 显示docker的系统信息，包括镜像和容器的数量docker 命令 --help # 帮助命令  docker不知道的命令 就用这个查阅</code></pre><p>官方文档地址：<a href="https://docs.docker.com/engine/reference/commandline/docker/" target="_blank" rel="noopener">https://docs.docker.com/engine/reference/commandline/docker/</a></p></li></ol><ol start="2"><li><p>镜像命令</p><pre class=" language-shell"><code class="language-shell">docker images # 查看所有本地主机上的镜像 可以使用docker image ls代替docker search # 搜索镜像docker pull # 下载镜像 docker image pull ，如果不写tag，默认就是latestdocker rmi # 删除镜像 docker image rm</code></pre><p>docker images查看所有本地的主机上的镜像</p><pre class=" language-shell"><code class="language-shell"># 解释#REPOSITORY         # 镜像的仓库源#TAG                # 镜像的标签(版本)        ---lastest 表示最新版本#IMAGE ID           # 镜像的id#CREATED            # 镜像的创建时间#SIZE               # 镜像的大小# 可选项Options:  -a, --all         Show all images (default hides intermediate images) #列出所有镜像  -q, --quiet       Only show numeric IDs # 只显示镜像的id</code></pre><p>这里可以使用一个骚操作：可以使用<code>docker rmi $(docker images -aq)</code></p></li></ol><ol start="3"><li><p>容器命令</p><p>根据官方导图，我们有了镜像才可以创建容器，我们来下载一个centos镜像</p><pre class=" language-shell"><code class="language-shell"># docker中下载centosdocker pull centos</code></pre><pre class=" language-shell"><code class="language-shell">docker run 镜像id      # 新建容器并启动docker ps             #列出所有运行的容器  等同于 docker container listdocker rm 容器id       # 删除指定容器docker start 容器id    # 启动容器docker restart 容器id  # 重启容器docker stop 容器id     # 停止当前正在运行的容器docker kill 容器id     # 强制停止当前容器exit                  # 容器直接退出ctrl +P +Q            # 容器不停止退出     ---注意：这个很有用的操作</code></pre><p>新建容器并启动</p><pre class=" language-shell"><code class="language-shell">docker run [可选参数] image  或者 docker container run [可选参数] image# 参数说明--name="Name"  # 容器名字 tomcat01 tomcat02 用来区分容器-d             # 后台方式运行-it            # 使用交互方式运行，进入容器查看内容-p             # 指定容器的端口 -p 8080(宿主机):8080(容器)     -p ip:主机端口:容器端口     -p 主机端口:容器端口(常用)     -p 容器端口-P(大写)        # 随机指定端口</code></pre><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/4.png" alt="4" style="width:85%;height:85%;"></li></ol><ol start="4"><li><p>其他常用命令</p><ol><li><p>后台启动命令：<code>docker run -d 镜像名</code></p></li><li><p>日志查看：</p></li></ol><pre class=" language-shell"><code class="language-shell">docker logs --helpOptions:      --details        Show extra details provided to logs *  -f, --follow         Follow log output      --since string   Show logs since timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)*      --tail string    Number of lines to show from the end of the logs (default "all")*  -t, --timestamps     Show timestamps      --until string   Show logs before a timestamp (e.g. 2013-01-02T13:23:37) or relative (e.g. 42m for 42 minutes)# 显示日志-tf                           # 显示日志信息（一直更新）--tail number                 # 需要显示日志条数docker logs -t --tail n 容器id # 查看n行日志docker logs -ft 容器id         # 跟着日志</code></pre><ol start="3"><li><p>查看容器容器中进程信息： <code>docker top 容器id</code></p></li><li><p>查看镜像元数据：<code>docker inspect 容器id</code>   很有用的</p></li><li><p>进入当前正在运行的容器：</p></li></ol><pre class=" language-shell"><code class="language-shell">docker exec -it 容器id /bash/shelldocker attach 容器id# 区别#docker exec   # 进入当前容器后开启一个新的终端，可以在里面操作#docker attach # 进入容器正在执行的终端</code></pre><ol start="6"><li>从容器内复制文件到主机上</li></ol><pre class=" language-shell"><code class="language-shell">docker cp 容器id:容器内路径  主机目的路径# eg: 无论容器是否启动都可以复制！docker cp 3f76dd01d08b:/text.java /home</code></pre><ol start="7"><li>commit镜像命令</li></ol><pre class=" language-shell"><code class="language-shell">docker commit # 提交容器成为一个新的副本# 命令和git原理类似docker commit -m="描述信息" -a="作者" 容器id 目标镜像名:[版本TAG]</code></pre><ol start="8"><li>导入导出命令</li></ol><pre class=" language-shell"><code class="language-shell"># 将容器导出成tar文件 -o 指定目录 docker export -o /root/docker/nginx1.tar d75e9fe433c8# 将tar文件导入成镜像  testnginx是REPOSITORY，1.0是tagdocker import -m '测试啊' nginx1.tar testnginx:1.0</code></pre><img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/7.png" alt="7" style="width:85%;height:85%;"></li></ol><p>   小结：</p>   <img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/5.png" alt="5" style="width:85%;height:85%;"><p>   命令总结：</p><pre class=" language-shell"><code class="language-shell">   attach      Attach local standard input, output, and error streams to a running container   #当前shell下 attach连接指定运行的镜像   build       Build an image from a Dockerfile # 通过Dockerfile定制镜像   commit      Create a new image from a container's changes #提交当前容器为新的镜像   cp          Copy files/folders between a container and the local filesystem #拷贝文件   create      Create a new container #创建一个新的容器   diff        Inspect changes to files or directories on a container's filesystem #查看docker容器的变化   events      Get real time events from the server # 从服务获取容器实时时间   exec        Run a command in a running container # 在运行中的容器上运行命令   export      Export a container's filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]   history     Show the history of an image # 展示一个镜像形成历史   images      List images #列出系统当前的镜像   import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像   info        Display system-wide information # 显示全系统信息   inspect     Return low-level information on Docker objects #查看容器详细信息   kill        Kill one or more running containers # kill指定docker容器   load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]   login       Log in to a Docker registry #   logout      Log out from a Docker registry   logs        Fetch the logs of a container   pause       Pause all processes within one or more containers   port        List port mappings or a specific mapping for the container   ps          List containers   pull        Pull an image or a repository from a registry   push        Push an image or a repository to a registry   rename      Rename a container   restart     Restart one or more containers   rm          Remove one or more containers   rmi         Remove one or more images   run         Run a command in a new container   save        Save one or more images to a tar archive (streamed to STDOUT by default)   search      Search the Docker Hub for images   start       Start one or more stopped containers   stats       Display a live stream of container(s) resource usage statistics   stop        Stop one or more running containers   tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE   top         Display the running processes of a container   unpause     Unpause all processes within one or more containers   update      Update configuration of one or more containers   version     Show the Docker version information   wait        Block until one or more containers stop, then print their exit codes</code></pre><h3 id="五、联合文件系统"><a href="#五、联合文件系统" class="headerlink" title="五、联合文件系统"></a>五、联合文件系统</h3><blockquote><p>UnionFs （联合文件系统）</p></blockquote><p>   UnionFs（联合文件系统）：Union文件系统（UnionFs）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像<br>   特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p><blockquote><p>Docker镜像加载原理</p></blockquote><p>   docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>   boots(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br>   rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p><blockquote><p>分层的镜像</p></blockquote><p>   我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载 </p>   <img src="http://staticfile.erdongchen.top/blog/blogPicture/20210430/6.png" alt="6" style="width:85%;height:85%;"><p>   Docker镜像要采用这种分层的结构最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p><p>   查看镜像分层的方式可以通过<code>docker image inspect</code>命令</p><p>   所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p><p>   举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>   就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合；</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容器化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于hexo从拉取博客源码到发布一篇博文总结</title>
      <link href="/2020/12/25/%E5%9F%BA%E4%BA%8Ehexo%E4%BB%8E%E6%8B%89%E5%8F%96%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%91%E5%B8%83%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%E6%80%BB%E7%BB%93/"/>
      <url>/2020/12/25/%E5%9F%BA%E4%BA%8Ehexo%E4%BB%8E%E6%8B%89%E5%8F%96%E5%8D%9A%E5%AE%A2%E6%BA%90%E7%A0%81%E5%88%B0%E5%8F%91%E5%B8%83%E4%B8%80%E7%AF%87%E5%8D%9A%E6%96%87%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>2020年快要结束，看看最后一篇博文，才发现已经有好几个月没有写写学习总结了，入职以来从没出差的我因为项目原因频繁出差，也是这个北京水文地质项目让我学到了很多，项目的开发周期缩短，也是得益于公司买了一套很实用的前后端开发框架(<a href="https://bladex.vip/#/" title="点击跳转" target="_blank" rel="noopener"><strong><font color="purple">blade官网</font></strong></a>)，这个框架属于商业版集成了很多组件，实用起来收放自如，解决了开园框架集成、配置的痛点；后续也会分享出来；由于去北京出差，某次偶然手机触碰了一下笔记本电脑，莫名其妙的把笔记本的硬盘整坏了，里面的东西全美了，心疼了我大半天，烦死了，回武汉后，要从0开始搭建博客环境和博客发布，因为长时间不用导致很多步骤都忘了，今天写一篇当做备忘笔记了。</p></blockquote><h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>环境准备；</li><li>拉取我的博客源码</li><li>创建一篇博文模版</li><li>编译生成待发布的静态文件</li><li>部署至网站</li></ol></blockquote><h3 id="二、环境准备；"><a href="#二、环境准备；" class="headerlink" title="二、环境准备；"></a>二、环境准备；</h3><ol><li>git version 2.29.2.windows.3</li><li>Node.js v12.14.1.</li><li>hexo: 3.9.0</li></ol><h3 id="三、拉取我的博客源码"><a href="#三、拉取我的博客源码" class="headerlink" title="三、拉取我的博客源码"></a>三、拉取我的博客源码</h3><pre class=" language-git"><code class="language-git">git clone https://github.com/a878804506/myBlogSourceCode.git</code></pre><h3 id="四、创建一篇博文模版"><a href="#四、创建一篇博文模版" class="headerlink" title="四、创建一篇博文模版"></a>四、创建一篇博文模版</h3><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true">## hexo new [layout] &lt;title> </span><span class="token comment" spellcheck="true">## 例如</span>hexo new test</code></pre><p> 创建命令如下：<br> <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20201225/4.1.jpg" align="left/"><br> 效果：<br> <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20201225/4.2.jpg" align="left/"></p><h3 id="五、编译生成待发布的静态文件"><a href="#五、编译生成待发布的静态文件" class="headerlink" title="五、编译生成待发布的静态文件"></a>五、编译生成待发布的静态文件</h3><p> 当一篇博文写好以后就可以启动服务，本地访问看看了，命令如下：</p><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true">##hexo clean 是清理生成的文件</span><span class="token comment" spellcheck="true">##hexo server / hexo s 启动服务器。默认情况下，访问网址为： http://localhost:4000/</span>hexo clean &amp;&amp; hexo server<span class="token comment" spellcheck="true">##默认访问地址就是 http://127.0.0.1:4000</span></code></pre><h3 id="六、部署至网站"><a href="#六、部署至网站" class="headerlink" title="六、部署至网站"></a>六、部署至网站</h3><pre class=" language-git"><code class="language-git"><span class="token comment" spellcheck="true">##hexo generate 或者 hexo g 根据源码编译成静态文件，放到服务器下，就可以访问</span><span class="token comment" spellcheck="true">##hexo deploy 或者 hexo d 部署至网站。这里部署的目标网站是配置在_config.yml 文件里面在，会自动吧文件提交至个人的github.io工程下</span>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code></pre><p><strong><font color="green">更多hexo命令可以查看官方文档：</font></strong><a href="https://hexo.io/zh-cn/docs/" title="点击跳转" target="_blank" rel="noopener"><strong><font color="purple">https://hexo.io/zh-cn/docs/</font></strong></a></p>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app个人作品介绍</title>
      <link href="/2020/06/30/uni-app%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E4%BB%8B%E7%BB%8D/"/>
      <url>/2020/06/30/uni-app%E4%B8%AA%E4%BA%BA%E4%BD%9C%E5%93%81%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>其实我一直就想开发一款属于自己的app，但能力有限，接触到uniapp后，就尝试了一下，感觉还可以，个人觉得uniapp入门容易深入难（或者是我太菜），这次就介绍一下我用uniapp开发的一款应用</p></blockquote><h3 id="一、本篇教程用的软件、技术和说明"><a href="#一、本篇教程用的软件、技术和说明" class="headerlink" title="一、本篇教程用的软件、技术和说明"></a>一、本篇教程用的软件、技术和说明</h3><ol><li>HBuilderX版本：2.7.14</li><li>Android-SDK版本：2.7.14</li></ol><h3 id="二、登录页"><a href="#二、登录页" class="headerlink" title="二、登录页"></a>二、登录页</h3> <img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200630/2.1.png" align="left/"><h3 id="三、首页"><a href="#三、首页" class="headerlink" title="三、首页"></a>三、首页</h3> <img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200630/3.1.png" align="left/"><h3 id="四、博客"><a href="#四、博客" class="headerlink" title="四、博客"></a>四、博客</h3> <img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200630/4.1.png" align="left/"><h3 id="五、音乐"><a href="#五、音乐" class="headerlink" title="五、音乐"></a>五、音乐</h3> <img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200630/5.1.png" align="left/"><h3 id="六、我"><a href="#六、我" class="headerlink" title="六、我"></a>六、我</h3> <img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200630/6.1.png" align="left/">]]></content>
      
      
      <categories>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 作品 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uni-app试玩</title>
      <link href="/2020/06/29/uni-app%E8%AF%95%E7%8E%A9/"/>
      <url>/2020/06/29/uni-app%E8%AF%95%E7%8E%A9/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>前段时间闲来无事，听朋友提到过uni-app，说它写一套代码，可多端（H5、android、IOS、微信小程序、支付宝小程序、头条小程序等等）打包，还是基于VUE封装的、听着很神奇，再加上我以前就有想法做一个属于自己的移动端应用，相对于做一款真正的android、ios应用来说，uni-app的门槛已经算是很低了，于是我就开始了盘uni-app之旅了，坑很多，且听我一一道来。</p></blockquote><h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>下载安装</li><li>新建一个HBuilderX应用及打包</li><li>android打包配置</li><li>打包成android应用</li><li>坑一</li><li>坑二</li><li>uni-app之我见</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>HBuilderX版本：2.7.14</li><li>Android-SDK版本：2.7.14</li></ol><h3 id="三、下载安装"><a href="#三、下载安装" class="headerlink" title="三、下载安装"></a>三、下载安装</h3><p> &#160; &#160;<a href="https://nativesupport.dcloud.net.cn/AppDocs/usesdk/android" title="download" target="_blank" rel="noopener"><strong><font color="purple">开发工具下载</font></strong></a>：需下载HBuilderX、需要打包成Android应用需要下载Android-SDK、Android Studio（打包时用）<br> 本篇文章只说从新建uni-app到打包成apk的过程，打包成ios、微信小程序等需要自己去官网看教程（应该都蛮简单）</p><h3 id="四、新建一个HBuilderX应用及打包"><a href="#四、新建一个HBuilderX应用及打包" class="headerlink" title="四、新建一个HBuilderX应用及打包"></a>四、新建一个HBuilderX应用及打包</h3><ol><li>这里直接新建一个带基础插件的uniapp模板项目，这里选项里面自带了所有的实用插件，到时候写项目的时候不用一个个下载了<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/4.1.png" align="left/"></li><li>HBuilderX直接打包刚刚新建的前端项目：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/4.2.png" align="left/"></li><li>成功打包前端项目后会输出如下目录<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/4.3.png" align="left/"></li></ol><h3 id="五、android打包配置"><a href="#五、android打包配置" class="headerlink" title="五、android打包配置"></a>五、android打包配置</h3><ol><li>打开Android Studio编辑器，导入Android-SDK中自带的项目，等待编辑器自动构建完成：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/5.1.png" align="left/"><font color="green">备注：之所以导入HBuilder-Integrate-AS是因为这个自带了uni-app打包成apk的SDK工具，不要再复制粘贴了</font></li><li>将在HBuilderX中打包好的前端项目导入到apps文件夹中，并删除这里面的示例项目<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/5.2.png" align="left/"></li></ol><h3 id="六、打包成android应用"><a href="#六、打包成android应用" class="headerlink" title="六、打包成android应用"></a>六、打包成android应用</h3><ol><li><p>修改如下几个地方的配置：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.1.png" align="left/"></li><li><p>引入uni-app的SDK：<br>将下图一中的uniapp-release.aar包放到图二位置</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.2.1.png" align="left/"><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.2.2.png" align="left/"></li><li><p>再把项目中的simpleDemo模块给删除掉，再自动构建一遍</p></li><li><p>打包成apk：<br>点击这里</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.4.1.png" align="left/">第一步<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.4.2.png" align="left/">第二步<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.4.3.png" align="left/"><font color="green">备注：这里的keystore可以用java生成一个免费的，百度即可</font><p>最后一步</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.4.4.png" align="left/"></li><li><p>安装app后看效果：<br>安装完毕后打开能看到这个页面就说明打包成功：</p><img style="width:40%;height:40%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/6.5.jpg" align="left/"></li></ol><h3 id="七、坑一"><a href="#七、坑一" class="headerlink" title="七、坑一"></a>七、坑一</h3><p> HBuilderX的版本和Android-SDK的版本需要一致，不然打包出来的app会有白屏的现象；</p><h3 id="八、坑二"><a href="#八、坑二" class="headerlink" title="八、坑二"></a>八、坑二</h3><p> 最开始打包成apk的时候可能会<strong><font color="red">报错</font></strong>：<br> <img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200629/8.1.png" align="left/"><br> <strong><font color="green">解决方案</font></strong>：将报错提示的模块复制粘贴到app模块下的build.gradle文件里面去，在重新编译打包即可</p><h3 id="九、uni-app之我见"><a href="#九、uni-app之我见" class="headerlink" title="九、uni-app之我见"></a>九、uni-app之我见</h3><ol><li>uniapp主打一套代码，各端编译。确实很吸引人，只有真正的摸过这个框架才知道这里面的水还是蛮深的，如果真想一套代码发布成app、各端小程序的话累死你，踩坑能踩到你断气！</li><li>uniapp出自国产，开箱即用，基于vue，上手简单，支持是必须的，更新迭代也非常快，也正是因为能多端编译，只有真正了解里面的套路之后才能快速开发；</li><li>uniapp的插件我感觉都是出自个人之手，并非官方，所以很多插件bug多多！官方最喜欢搞什么插件大赛，让各路牛鬼蛇神去参加，好的插件就可以放到插件市场，供开发者使用，基础插件好用到是好用，但是高级点的就bug多多或者作者收费；（bug多也正是因为个人插件没有全平台测试就发布出来，用的人不小心就成了踩坑倒霉蛋了）</li><li>可能uniapp的官方团队重心放在各端的SDK版本迭代和bug修复上，周边插件上并不是那么完善</li></ol>]]></content>
      
      
      <categories>
          
          <category> uni-app </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 框架 </tag>
            
            <tag> 学习 </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataX-自定义Transformer的使用和扩展以及运行参数调优</title>
      <link href="/2020/05/26/DataX-%E8%87%AA%E5%AE%9A%E4%B9%89Transformer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%89%A9%E5%B1%95%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/"/>
      <url>/2020/05/26/DataX-%E8%87%AA%E5%AE%9A%E4%B9%89Transformer%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%89%A9%E5%B1%95%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong><font color="green">写在前面</font></strong>：在使用数据同步工具的时候，在业务上往往不会是简单的从A库到B库，我公司现在使用的数据交换平台也有函数转换功能，最近玩DataX的时候发现她自带了字段转换预处理功能，特来实战一下。</p></blockquote><h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>使用Transformer时的job.json的配置示例；</li><li>dx_substr的使用示例；</li><li>dx_pad的使用示例；</li><li>dx_replace的使用示例；</li><li>dx_filter的使用示例；</li><li>dx_groovy执行自定义代码；</li><li>扩展Transformer；</li><li>DataX的同步性能调优；</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>jdk版本：1.8.0_202-b08；</li><li>Python版本：2.7.18（官方推荐2.6.X）；</li><li>Maven版本；3.6.0 ；</li><li>DataX是直接拉取的master分支上的源码；</li></ol></blockquote><h3 id="三、使用Transformer时的job-json的配置示例"><a href="#三、使用Transformer时的job-json的配置示例" class="headerlink" title="三、使用Transformer时的job.json的配置示例"></a>三、使用Transformer时的job.json的配置示例</h3><ol><li>git上面DataX也对Transformer做了使用介绍，地址是：<a href="https://github.com/alibaba/DataX/blob/master/transformer/doc/transformer.md" title="跳转" target="_blank" rel="noopener"><strong><font color="green">跳转</font></strong></a></li><li>使用转换配置的完整示例：该示例是字符串的截取示例，后面会对每一种的字段处理做详细介绍和demo<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         // 使用字段截取转换         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_substr"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           // 操作读取出来的record的第一列           <span class="token property">"columnIndex"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>           // 意思是截取第<span class="token number">0</span>到<span class="token number">4</span>个字符           <span class="token property">"paras"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mysqlreader"</span><span class="token punctuation">,</span>       <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>         <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>         <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>         <span class="token property">"column"</span><span class="token operator">:</span> <span class="token punctuation">[</span>           <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>           <span class="token string">"LOAD_TIME"</span><span class="token punctuation">,</span>           <span class="token string">"DATA_TIME"</span><span class="token punctuation">,</span>           <span class="token string">"POS_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"REV_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_Q_E_1"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_Q_E_2"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_1_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_2_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_3_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_4_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"DATA_FLAG"</span>         <span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token property">"splitPk"</span><span class="token operator">:</span> <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>         <span class="token property">"connection"</span><span class="token operator">:</span> <span class="token punctuation">[</span>           <span class="token punctuation">{</span>             <span class="token property">"table"</span><span class="token operator">:</span> <span class="token punctuation">[</span>               <span class="token string">"dr_e_raw_hour_202004_debug"</span>             <span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token property">"jdbcUrl"</span><span class="token operator">:</span> <span class="token punctuation">[</span>               <span class="token string">"jdbc:mysql://192.168.1.202:3306/test"</span>             <span class="token punctuation">]</span>           <span class="token punctuation">}</span>         <span class="token punctuation">]</span>       <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mysqlwriter"</span><span class="token punctuation">,</span>       <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>         <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>         <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>         <span class="token property">"column"</span><span class="token operator">:</span> <span class="token punctuation">[</span>           <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>           <span class="token string">"LOAD_TIME"</span><span class="token punctuation">,</span>           <span class="token string">"DATA_TIME"</span><span class="token punctuation">,</span>           <span class="token string">"POS_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"REV_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_P_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_Q_E_1"</span><span class="token punctuation">,</span>           <span class="token string">"GROUP_Q_E_2"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_1_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_2_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_3_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"QUAD_4_Q_E_TOTAL"</span><span class="token punctuation">,</span>           <span class="token string">"DATA_FLAG"</span>         <span class="token punctuation">]</span><span class="token punctuation">,</span>         <span class="token property">"connection"</span><span class="token operator">:</span> <span class="token punctuation">[</span>           <span class="token punctuation">{</span>             <span class="token property">"table"</span><span class="token operator">:</span> <span class="token punctuation">[</span>               <span class="token string">"dr_e_raw_hour_202004_debug"</span>             <span class="token punctuation">]</span><span class="token punctuation">,</span>             <span class="token property">"jdbcUrl"</span><span class="token operator">:</span> <span class="token string">"jdbc:mysql://192.168.1.202:3306/test1"</span>           <span class="token punctuation">}</span>         <span class="token punctuation">]</span>       <span class="token punctuation">}</span>     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="四、dx-substr的使用示例"><a href="#四、dx-substr的使用示例" class="headerlink" title="四、dx_substr的使用示例"></a>四、dx_substr的使用示例</h3><ol><li>配置demo<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         // 使用字段截取转换         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_substr"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           // 操作读取出来的record的第一列           <span class="token property">"columnIndex"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>           // 意思是截取第<span class="token number">0</span>到<span class="token number">4</span>个字符           <span class="token property">"paras"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">,</span><span class="token string">"4"</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 reader     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 writer     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>运行后的效果<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/4.2.png" align="left/"></li></ol><h3 id="五、dx-pad的使用示例"><a href="#五、dx-pad的使用示例" class="headerlink" title="五、dx_pad的使用示例"></a>五、dx_pad的使用示例</h3><ol><li>配置demo<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_pad"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token property">"columnIndex"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>           // 第一个参数是在字段左边补位还是右边补位，可选参数有 l<span class="token operator">:</span>左边 、r<span class="token operator">:</span>右边           // 第二个参数是目标字段的长度           // 第三个参数是需要补位的字符           // 返回：如果源字符串长度小于目标字段长度，按照位置添加pad字符后返回。如果长于，直接截断（都截右边）。如果字段为空值，转换为空字符串进行pad，即最后的字符串全是需要pad的字符           <span class="token property">"paras"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"l"</span><span class="token punctuation">,</span><span class="token string">"14"</span><span class="token punctuation">,</span><span class="token string">"x"</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 reader     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 writer     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>运行后的效果<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/5.2.png" align="left/"></li></ol><h3 id="六、dx-replace的使用示例"><a href="#六、dx-replace的使用示例" class="headerlink" title="六、dx_replace的使用示例"></a>六、dx_replace的使用示例</h3><ol><li>配置demo<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_replace"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token property">"columnIndex"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>           //第一个参数：字段值的开始位置。           //第二个参数：需要替换的字段长度。           //第三个参数：需要替换的字符串。           //返回： 从字符串的指定位置（包含）替换指定长度的字符串。如果开始位置非法抛出异常。如果字段为空值，直接返回（即不参与本transformer）           <span class="token property">"paras"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"3"</span><span class="token punctuation">,</span><span class="token string">"7"</span><span class="token punctuation">,</span><span class="token string">"x"</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 reader     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 writer     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>运行后的效果<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/6.2.png" align="left/"></li></ol><h3 id="七、dx-filter的使用示例"><a href="#七、dx-filter的使用示例" class="headerlink" title="七、dx_filter的使用示例"></a>七、dx_filter的使用示例</h3><ol><li>配置demo<pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_filter"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token property">"columnIndex"</span><span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span>           //第一个参数：运算符，支持一下运算符：like<span class="token punctuation">,</span> not like<span class="token punctuation">,</span> ><span class="token punctuation">,</span> =<span class="token punctuation">,</span> &lt;<span class="token punctuation">,</span> >=<span class="token punctuation">,</span> !=<span class="token punctuation">,</span> &lt;=           //第二个参数：正则表达式（java正则表达式）、值。           //返回：           //<span class="token number">1</span>、如果匹配正则表达式，返回<span class="token null">Null</span>，表示过滤该行。不匹配表达式时，表示保留该行。（注意是该行）。对于>=&lt;都是对字段直接compare的结果.           //<span class="token number">2</span>、like ， not like是将字段转换成String，然后和目标正则表达式进行全匹配。           //<span class="token punctuation">,</span> =<span class="token punctuation">,</span> &lt;<span class="token punctuation">,</span> >=<span class="token punctuation">,</span> !=<span class="token punctuation">,</span> &lt;= 对于DoubleColumn比较double值，对于LongColumn和DateColumn比较long值，其他StringColumn，BooleanColumn以及ByteColumn均比较的是StringColumn值。           //<span class="token number">3</span>、如果目标colunn为空（<span class="token null">null</span>），对于如果目标colunn为空（<span class="token null">null</span>），对于 = <span class="token null">null</span>的过滤条件，将满足条件，被过滤。！=<span class="token null">null</span>的过滤条件，<span class="token null">null</span>不满足过滤条件，不被过滤。 like，字段为<span class="token null">null</span>不满足条件，不被过滤，和not like，字段为<span class="token null">null</span>满足条件，被过滤。           <span class="token property">"paras"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"like"</span><span class="token punctuation">,</span><span class="token string">"102000000008"</span><span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 reader     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 writer     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li>运行后的效果<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/7.2.png" align="left/"></li></ol><h3 id="八、dx-groovy执行自定义代码"><a href="#八、dx-groovy执行自定义代码" class="headerlink" title="八、dx_groovy执行自定义代码"></a>八、dx_groovy执行自定义代码</h3><ol><li><p>dx_groovy就比较有意思了，它可以执行自定义的代码，使用这个转换可以实现上述4种类型的转换，你可以获取到读取出来的每一条记录（record），也就可以得到每条记录的每一列，然后做你想做的事情。</p></li><li><p>如下json配置，业务上需要取LOAD_TIME和DATA_TIME时间字段做比较，如果LOAD_TIME比DATA_TIME还要晚一些，说明这条数据就要废弃掉，就把DATA_FLAG标识为0。</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>   <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span>   <span class="token punctuation">}</span><span class="token punctuation">,</span>   <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>     <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>   <span class="token punctuation">{</span>     // 字段转换部分     <span class="token property">"transformer"</span><span class="token operator">:</span> <span class="token punctuation">[</span>       <span class="token punctuation">{</span>         //自定义转换         <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"dx_groovy"</span><span class="token punctuation">,</span>         <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>           <span class="token property">"code"</span><span class="token operator">:</span> <span class="token string">"Column loadTimeColumn = record.getColumn(1);           Column dataTimeColumn = record.getColumn(2);           Date loadTime = loadTimeColumn.asDate();           Date dataTime = dataTimeColumn.asDate();           if(loadTime.after(dataTime)){           record.setColumn(12,new LongColumn(0l));           return record;           }else{return record;}"</span><span class="token punctuation">,</span>           <span class="token property">"extraPackage"</span><span class="token operator">:</span> <span class="token punctuation">[</span>             <span class="token string">""</span>           <span class="token punctuation">]</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>     <span class="token punctuation">]</span><span class="token punctuation">,</span>     <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 reader     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>       // 略去 writer     <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>运行后的效果</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/8.3.png" align="left/"></li><li><p>extraPackage参数是需要导入的包名，阅读<code>GroovyTransformer</code>类源码可知道，在使用dx_groovy的时候会自动加载如下常用类：</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200526/8.4.png" align="left/">所以说在使用dx_groovy时，需要引用到上述包的时候，可以不用写包的引用，特别是util包；</li><li><p>值得注意的是：dx_groovy它引用了这个包<code>import static com.alibaba.datax.core.transport.transformer.GroovyTransformerStaticUtil.*</code>,而这个静态类中目前是空的，阿里的大佬已经为你考虑到：当你需要编写大量逻辑的时候，你可以直接写在这个类中（当然要声明成静态方法），然后编译DataX，当再次使用dx_groovy时，可直接<code>GroovyTransformerStaticUtil.方法</code>的的形式调用，来执行你的逻辑！</p></li></ol><h3 id="九、扩展Transformer"><a href="#九、扩展Transformer" class="headerlink" title="九、扩展Transformer"></a>九、扩展Transformer</h3><p> 如果使用dx_groovy还不够酷炫，还不能满足业务需求，还可以对Transformer模块进行扩展，编写自己的特有的Transformer模块，方法如下：</p><ol><li>下载DataX源码，在com.alibaba.datax.core.transport.transformer包下，新建一个类继承Transformer，可以参照已有的类（FilterTransformer、GroovyTransformer等等）</li><li>在TransformerRegistry类的静态代码块中注册你的类</li><li>编译打包DataX，在job.json中使用<code>&quot;transformer&quot;: []</code>模块</li></ol><h3 id="十、DataX的同步性能调优"><a href="#十、DataX的同步性能调优" class="headerlink" title="十、DataX的同步性能调优"></a>十、DataX的同步性能调优</h3><ol><li><p>全局参数</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span><span class="token property">"core"</span><span class="token operator">:</span><span class="token punctuation">{</span>     <span class="token property">"transport"</span><span class="token operator">:</span><span class="token punctuation">{</span>         <span class="token property">"channel"</span><span class="token operator">:</span><span class="token punctuation">{</span>             <span class="token property">"speed"</span><span class="token operator">:</span><span class="token punctuation">{</span>                 <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span> ## 数据导入的并发度                 <span class="token property">"record"</span><span class="token operator">:</span>-<span class="token number">1</span><span class="token punctuation">,</span> ##解除对读取行数的限制                 <span class="token property">"byte"</span><span class="token operator">:</span>-<span class="token number">1</span><span class="token punctuation">,</span> ##解除对字节的限制                 <span class="token property">"batchSize"</span><span class="token operator">:</span><span class="token number">2048</span> ##每次读取batch的大小             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token property">"job"</span><span class="token operator">:</span><span class="token punctuation">{</span>         ...     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li><li><p>局部参数</p><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span> <span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span>     ....     <span class="token punctuation">}</span><span class="token punctuation">,</span>     <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>         <span class="token punctuation">{</span>             <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                 <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mysqlreader"</span><span class="token punctuation">,</span>                 <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>                     <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>                     <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>                     <span class="token property">"column"</span><span class="token operator">:</span> <span class="token punctuation">[</span>*<span class="token punctuation">]</span><span class="token punctuation">,</span>                     <span class="token property">"splitPk"</span><span class="token operator">:</span> <span class="token string">"db_id"</span><span class="token punctuation">,</span> ## 必须指定切分键并发才生效                     <span class="token property">"connection"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                         ......                             <span class="token punctuation">]</span>                         <span class="token punctuation">}</span>                     <span class="token punctuation">]</span>                 <span class="token punctuation">}</span>             <span class="token punctuation">}</span><span class="token punctuation">,</span>            <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span></code></pre><ol><li>channel增大，可根据服务器的实际配置修改datax.py，提升-Xms与-Xmx，来防止OOM。</li><li>DEFAULT_JVM = “-Xms1g -Xmx1g -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=%s/log” % (DATAX_HOME)</li><li>channel并不是越大越好，过分大反而会影响宿主机的性能。</li></ol></li><li><p>jvm调优，可根据服务器条件为job设置合适等jvm大小<br><code>$ python ./bin/datax.py  --jvm=&quot;-Xms512m -Xmx512m&quot; ./job/stream2stream.json</code><br><code>$ python ./bin/datax.py  --jvm=&quot;-Xms1G -Xmx1G&quot; ./job/job.json</code></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> DataX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataX-通过debug对DataX源码进行解析</title>
      <link href="/2020/04/28/DataX-%E9%80%9A%E8%BF%87debug%E5%AF%B9DataX%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/"/>
      <url>/2020/04/28/DataX-%E9%80%9A%E8%BF%87debug%E5%AF%B9DataX%E6%BA%90%E7%A0%81%E8%BF%9B%E8%A1%8C%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong><font color="green">写在前面</font></strong>：公司项目上用到了kettle作为项目的底层同步工具，后来kettle无法满足大数据和分布式环境下的数据同步，也把DataX集成进来，我对DataX同步只是停留在使用上，这次花了几天时间调试DataX源码和百度资料，把这几天的收获总结一下，为后面开发插件做铺垫。废话少说，开始上代码！</p></blockquote><h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>总体图解DataX；</li><li>准备json配置文件；</li><li>DataX的主程序入口Engine的解析；</li><li>JobContainer.start()方法做了哪些事？</li><li>JobContainer：init()实例化reader、writer的job对象；</li><li>JobContainer：split()根据用户配置拆分job成多个task；</li><li>JobContainer：schedule()将reader和writer split的结果整合到具体taskGroupContainer中,同时所有任务调度起来；</li><li>AbstractScheduler：统领全局，周期性汇报日志；</li><li>ProcessInnerScheduler：；创建并启动固定的线程数的TaskGroupContainerRunner；</li><li>TaskGroupContainer：分配的Task，创建并执行TaskExecutor；</li><li>TaskExecutor：一个完整task的执行器；</li><li>invokeHooks用法？</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>jdk版本：1.8.0_202-b08；</li><li>Python版本：2.7.18（官方推荐2.6.X）；</li><li>Maven版本；3.6.0 ；</li><li>DataX是直接拉取的master分支上的源码；</li><li><strong><font color="green">本篇文章也是跟着代码流程走的，根据DataX的图解、按照解析步骤往下看，然后自己多调试几遍，基本上都可以理解清楚DataX内部的核心工作流程，另外本篇篇幅较长，需耐心揣摩和调试。</font></strong>；</li></ol></blockquote><h3 id="三、总体图解DataX"><a href="#三、总体图解DataX" class="headerlink" title="三、总体图解DataX"></a>三、总体图解DataX</h3><ol><li>先上一张github上官方描述图：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/3.1.png" align="left/">官方图已经把DataX的整个架构说明的很清楚：用户提交一个job，会根据用户配置、核心配置、使用到的插件配置将job拆分成多个task，然后会很公平的将task分组成多个taskGroup，然后在根据taskGroup的数量创建固定数量的线程池去运行task。</li><li>再上一张更细分的图解(这张图有点大，加载较慢)：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/3.2.jpg" align="left/">如果要是还没有开始看源码，先看看这张图，知道了运行流程再去看源码，会更好理解，如果已经看完源码在看这张图，对DataX的源码更能加深印象。</li></ol><h3 id="四、准备json配置文件"><a href="#四、准备json配置文件" class="headerlink" title="四、准备json配置文件"></a>四、准备json配置文件</h3><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"job"</span><span class="token operator">:</span> <span class="token punctuation">{</span>    <span class="token property">"setting"</span><span class="token operator">:</span> <span class="token punctuation">{</span>      <span class="token property">"speed"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"channel"</span><span class="token operator">:</span> <span class="token number">10</span>      <span class="token punctuation">}</span><span class="token punctuation">,</span>      <span class="token property">"errorLimit"</span><span class="token operator">:</span> <span class="token punctuation">{</span>        <span class="token property">"record"</span><span class="token operator">:</span> <span class="token number">10000</span><span class="token punctuation">,</span>        <span class="token property">"percentage"</span><span class="token operator">:</span> <span class="token number">1</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token property">"content"</span><span class="token operator">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        <span class="token property">"reader"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mysqlreader"</span><span class="token punctuation">,</span>          <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            <span class="token property">"column"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>              <span class="token string">"LOAD_TIME"</span><span class="token punctuation">,</span>              <span class="token string">"DATA_TIME"</span><span class="token punctuation">,</span>              <span class="token string">"POS_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"REV_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_Q_E_1"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_Q_E_2"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_1_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_2_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_3_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_4_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"DATA_FLAG"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"splitPk"</span><span class="token operator">:</span> <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>            <span class="token property">"connection"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                  <span class="token string">"dr_e_raw_hour_202004_debug"</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token property">"jdbcUrl"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                  <span class="token string">"jdbc:mysql://192.168.1.202:3306/test"</span>                <span class="token punctuation">]</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span>        <span class="token property">"writer"</span><span class="token operator">:</span> <span class="token punctuation">{</span>          <span class="token property">"name"</span><span class="token operator">:</span> <span class="token string">"mysqlwriter"</span><span class="token punctuation">,</span>          <span class="token property">"parameter"</span><span class="token operator">:</span> <span class="token punctuation">{</span>            <span class="token property">"username"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            <span class="token property">"password"</span><span class="token operator">:</span> <span class="token string">"root"</span><span class="token punctuation">,</span>            <span class="token property">"column"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token string">"MP_ID"</span><span class="token punctuation">,</span>              <span class="token string">"LOAD_TIME"</span><span class="token punctuation">,</span>              <span class="token string">"DATA_TIME"</span><span class="token punctuation">,</span>              <span class="token string">"POS_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"REV_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_P_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_Q_E_1"</span><span class="token punctuation">,</span>              <span class="token string">"GROUP_Q_E_2"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_1_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_2_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_3_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"QUAD_4_Q_E_TOTAL"</span><span class="token punctuation">,</span>              <span class="token string">"DATA_FLAG"</span>            <span class="token punctuation">]</span><span class="token punctuation">,</span>            <span class="token property">"connection"</span><span class="token operator">:</span> <span class="token punctuation">[</span>              <span class="token punctuation">{</span>                <span class="token property">"table"</span><span class="token operator">:</span> <span class="token punctuation">[</span>                  <span class="token string">"dr_e_raw_hour_202004_debug"</span>                <span class="token punctuation">]</span><span class="token punctuation">,</span>                <span class="token property">"jdbcUrl"</span><span class="token operator">:</span> <span class="token string">"jdbc:mysql://192.168.1.202:3306/test1"</span>              <span class="token punctuation">}</span>            <span class="token punctuation">]</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p> <strong><font color="red">防坑</font></strong>：这个json没什么特别的，主要是配置了切分规则job.content.reader.parameter.splitPk=”MP_ID”和job.setting.speed.channel=10，配置这两个参数主要是一会debug的时候，DataX会根据job拆分成多个task，如果不配置splitPk，那么程序不会并发的去同步数据！</p><h3 id="五、DataX的主程序入口Engine的解析"><a href="#五、DataX的主程序入口Engine的解析" class="headerlink" title="五、DataX的主程序入口Engine的解析"></a>五、DataX的主程序入口Engine的解析</h3><ol><li><p>Engine.entry(final String[] args)的方法解析如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 说明：* entry 函数主要做两件事情，分别是：** 1、解析job相关配置生成configuration。* 2、依据配置启动Engine。*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">entry</span><span class="token punctuation">(</span><span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Throwable <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//省略代码</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 获取job的配置路径信息  */</span> String jobPath <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">getOptionValue</span><span class="token punctuation">(</span><span class="token string">"job"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//省略代码</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 划重点-解析配置信息  */</span> Configuration configuration <span class="token operator">=</span> ConfigParser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>jobPath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//省略代码</span> Engine engine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 说明：  * start过程中做了两件事：  *  * 1、创建JobContainer对象  * 2、启动JobContainer对象  */</span> engine<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>划重点-Configuration configuration = ConfigParser.parse(jobPath)代码解析：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** by 耳东陈* 说明：* configuration解析包括三部分的配置解析合并解析结果并返回，分别是：** 1、解析job的配置信息，由启动参数指定job.json文件。* 2、解析DataX自带配置信息，由默认指定的core.json文件。* 3、解析读写插件配置信息，由job.json指定的reader和writer插件信息*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> Configuration <span class="token function">parse</span><span class="token punctuation">(</span><span class="token keyword">final</span> String jobPath<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 加载任务的指定的配置文件，这个配置是有固定的json的固定模板格式的  */</span> Configuration configuration <span class="token operator">=</span> ConfigParser<span class="token punctuation">.</span><span class="token function">parseJobConfig</span><span class="token punctuation">(</span>jobPath<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 合并conf/core.json的配置文件  */</span> configuration<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>         ConfigParser<span class="token punctuation">.</span><span class="token function">parseCoreConfig</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>DATAX_CONF_PATH<span class="token punctuation">)</span><span class="token punctuation">,</span>         <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// todo config优化，只捕获需要的plugin</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 固定的节点路径 job.content[0].reader.name  */</span> String readerPluginName <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>         CoreConstant<span class="token punctuation">.</span>DATAX_JOB_CONTENT_READER_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> String writerPluginName <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>         CoreConstant<span class="token punctuation">.</span>DATAX_JOB_CONTENT_WRITER_NAME<span class="token punctuation">)</span><span class="token punctuation">;</span> String preHandlerName <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>         CoreConstant<span class="token punctuation">.</span>DATAX_JOB_PREHANDLER_PLUGINNAME<span class="token punctuation">)</span><span class="token punctuation">;</span> String postHandlerName <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>         CoreConstant<span class="token punctuation">.</span>DATAX_JOB_POSTHANDLER_PLUGINNAME<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/**  * by 耳东陈  * 添加读写插件的列表待加载  */</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> pluginList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> pluginList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>readerPluginName<span class="token punctuation">)</span><span class="token punctuation">;</span> pluginList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>writerPluginName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>preHandlerName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     pluginList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>preHandlerName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">if</span><span class="token punctuation">(</span>StringUtils<span class="token punctuation">.</span><span class="token function">isNotEmpty</span><span class="token punctuation">(</span>postHandlerName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     pluginList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>postHandlerName<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">/**      * by 耳东陈      * parsePluginConfig(new ArrayList&lt;String>(pluginList))加载指定的插件的配置信息，并且和全局的配置文件进行合并      */</span>     configuration<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">parsePluginConfig</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>pluginList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//吞掉异常，保持log干净。这里message足够。</span>     LOG<span class="token punctuation">.</span><span class="token function">warn</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"插件[%s,%s]加载失败，1s后重试... Exception:%s "</span><span class="token punctuation">,</span> readerPluginName<span class="token punctuation">,</span> writerPluginName<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">try</span> <span class="token punctuation">{</span>         Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment" spellcheck="true">//</span>     <span class="token punctuation">}</span>     configuration<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">parsePluginConfig</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span>pluginList<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> configuration<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><h3 id="六、JobContainer-start-方法做了哪些事？"><a href="#六、JobContainer-start-方法做了哪些事？" class="headerlink" title="六、JobContainer.start()方法做了哪些事？"></a>六、JobContainer.start()方法做了哪些事？</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * jobContainer主要负责的工作全部在start()里面，包括init、prepare、split、scheduler、 * post以及destroy和statistics */</span><span class="token comment" spellcheck="true">/** * by 耳东陈 * 说明： * JobContainer的start方法会执行一系列job相关的操作，如下： * * 1、执行job的preHandle()操作，暂时不关注。 * 2、执行job的init()操作，需重点关注。 * 3、执行job的prepare()操作，暂时不关注。 * 4、执行job的split()操作，需重点关注。 * 5、执行job的schedule()操作，需重点关注。 * 6、执行job的post()和postHandle()操作，暂时不关注。 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"DataX jobContainer starts job."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> hasException <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> isDryRun <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>startTimeStamp <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        isDryRun <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">getBool</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>DATAX_JOB_SETTING_DRYRUN<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>isDryRun<span class="token punctuation">)</span> <span class="token punctuation">{</span>            LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do preCheck ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preCheck</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 拷贝一份新的配置，保证线程安全             */</span>            userConf <span class="token operator">=</span> configuration<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do preHandle ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 执行preHandle()操作             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do init ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do prepare ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 执行plugin的prepare             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do split ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 说明：             * DataX的job的split过程主要是根据限流配置计算channel的个数，进而计算task的个数             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>totalStage <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do schedule ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 执行任务调度             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do post ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 执行后置操作             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"jobContainer starts to do postHandle ..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">/**             * by 耳东陈             * 执行postHandle操作             */</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">postHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"DataX jobId [{}] completed successfully."</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>jobId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">invokeHooks</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//省略代码</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//省略代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="七、JobContainer：init-实例化reader、writer的job对象"><a href="#七、JobContainer：init-实例化reader、writer的job对象" class="headerlink" title="七、JobContainer：init()实例化reader、writer的job对象"></a>七、JobContainer：init()实例化reader、writer的job对象</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * reader和writer的初始化 */</span> <span class="token comment" spellcheck="true">/** * by 耳东陈 * 说明： * Job的init()过程主要做了两个事情，分别是: * * 1、创建reader的job对象，通过URLClassLoader实现类加载。 * 2、创建writer的job对象，通过URLClassLoader实现类加载。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>jobId <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">getLong</span><span class="token punctuation">(</span>            CoreConstant<span class="token punctuation">.</span>DATAX_CORE_CONTAINER_JOB_ID<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>jobId <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Set jobId = 0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>jobId <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>DATAX_CORE_CONTAINER_JOB_ID<span class="token punctuation">,</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>jobId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"job-"</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>jobId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * 初始化     */</span>    JobPluginCollector jobPluginCollector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultJobPluginCollector</span><span class="token punctuation">(</span>            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getContainerCommunicator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//必须先Reader ，后Writer</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>jobReader <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initJobReader</span><span class="token punctuation">(</span>jobPluginCollector<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>jobWriter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initJobWriter</span><span class="token punctuation">(</span>jobPluginCollector<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="八、JobContainer：split-根据用户配置拆分job成多个task"><a href="#八、JobContainer：split-根据用户配置拆分job成多个task" class="headerlink" title="八、JobContainer：split()根据用户配置拆分job成多个task"></a>八、JobContainer：split()根据用户配置拆分job成多个task</h3><ol><li>DataX的job的split过程主要是根据限流配置计算channel的个数，进而计算task的个数，主要过程如下：<br>①、adjustChannelNumber的过程根据按照字节限流和record限流计算channel的个数。<br>②、reader的个数根据channel的个数进行计算。<br>③、writer的个数根据reader的个数进行计算，writer和reader实现1:1绑定。<br>④、通过mergeReaderAndWriterTaskConfigs()方法生成reader+writer的task的configuration，至此我们生成了task的配置信息。</li><li>adjustChannelNumber()方法是计算needChannelNumber的数量<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/8.2.png" align="left/"></li><li>this.doReaderSplit(this.needChannelNumber)根据channel的个数进行计算readerTask，该方法最终会调用ReaderSplitUtil.doSplit(Configuration originalSliceConfig, int adviceNumber)方法，其逻辑是：根据用户配置的splitPk，去数据库查询最大值和最小值，在根据计算出来的channel个数去切分N个sql语句，每个sql语句会被包装成一个task去运行；<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/8.3.1.png" align="left/"><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/8.3.2.png" align="left/"></li><li>mergeReaderAndWriterTaskConfigs()方法是生成task配置信息<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/8.4.png" align="left/">拆分逻辑至此结束。</li></ol><h3 id="九、JobContainer：schedule-的作用"><a href="#九、JobContainer：schedule-的作用" class="headerlink" title="九、JobContainer：schedule()的作用"></a>九、JobContainer：schedule()的作用</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * schedule首先完成的工作是把上一步reader和writer split的结果整合到具体taskGroupContainer中, * 同时不同的执行模式调用不同的调度策略，将所有任务调度起来 */</span><span class="token comment" spellcheck="true">/** * by 耳东陈 * 执行任务调度 * 说明： * Job的schedule的过程主要做了两件事，分别是： * * 1、将task拆分成taskGroup，生成List&lt;Configuration> taskGroupConfigs。 * 2、启动taskgroup的对象， scheduler.schedule(taskGroupConfigs)。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">schedule</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里的全局speed和每个channel的速度设置为B/s     */</span>    <span class="token keyword">int</span> channelsPerTaskGroup <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>            CoreConstant<span class="token punctuation">.</span>DATAX_CORE_CONTAINER_TASKGROUP_CHANNEL<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> taskNumber <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span>            CoreConstant<span class="token punctuation">.</span>DATAX_JOB_CONTENT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>needChannelNumber <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>needChannelNumber<span class="token punctuation">,</span> taskNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>    PerfTrace<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setChannelNumber</span><span class="token punctuation">(</span>needChannelNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * 这里会公平的将task任务分成多个taskGroup，在后面会根据每组任务数量创建线程池，执行task     * 通过获取配置信息得到每个taskGroup需要运行哪些tasks任务     */</span>    List<span class="token operator">&lt;</span>Configuration<span class="token operator">></span> taskGroupConfigs <span class="token operator">=</span> JobAssignUtil<span class="token punctuation">.</span><span class="token function">assignFairly</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">,</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>needChannelNumber<span class="token punctuation">,</span> channelsPerTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>    LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"Scheduler starts [{}] taskGroups."</span><span class="token punctuation">,</span> taskGroupConfigs<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ExecuteMode executeMode <span class="token operator">=</span> null<span class="token punctuation">;</span>    AbstractScheduler scheduler<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//省略代码</span>        <span class="token comment" spellcheck="true">/**         * by 耳东陈         * 开始调度所有的taskGroup         */</span>        scheduler<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>taskGroupConfigs<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>endTransferTimeStamp <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//省略代码</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 检查任务执行情况     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">checkLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="十、AbstractScheduler：统领全局，周期性汇报日志"><a href="#十、AbstractScheduler：统领全局，周期性汇报日志" class="headerlink" title="十、AbstractScheduler：统领全局，周期性汇报日志"></a>十、AbstractScheduler：统领全局，周期性汇报日志</h3><ol><li>startAllTaskGroup(configurations);此方法会启动所有的TaskGroup</li><li>进入while循环，循环体内部逻辑为：<br>①、收集任务状态；<br>②、获取报告，然后报告；<br>Communication reportCommunication = CommunicationTool.getReportCommunication(nowJobContainerCommunication, lastJobContainerCommunication, totalTasks);<br>this.containerCommunicator.report(reportCommunication);<br>③、错误限制检查；<br>errorLimit.checkRecordLimit(nowJobContainerCommunication);<br>④、判断所有的taskGroup是不是都已经完成了，执行完成就退出；<br>nowJobContainerCommunication.getState() == State.SUCCEEDED<br>⑤、判断进程状态；dealKillingStat()<br>⑥、判断失败状态；dealFailedStat()<br>⑦、刷新上一个作业状态，然后在下一个时间睡眠；</li></ol><h3 id="十一、ProcessInnerScheduler：；创建并启动固定的线程数的TaskGroupContainerRunner；"><a href="#十一、ProcessInnerScheduler：；创建并启动固定的线程数的TaskGroupContainerRunner；" class="headerlink" title="十一、ProcessInnerScheduler：；创建并启动固定的线程数的TaskGroupContainerRunner；"></a>十一、ProcessInnerScheduler：；创建并启动固定的线程数的TaskGroupContainerRunner；</h3><p>ProcessInnerScheduler的startAllTaskGroup方式是重写了AbstractScheduler的startAllTaskGroup方法，其逻辑很明朗</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * by 耳东陈 * 说明： * TaskGroup的Schedule方法做的事情如下： * * 1、为所有的TaskGroup创建TaskGroupContainerRunner。 * 2、通过线程池提交TaskGroupContainerRunner任务，执行TaskGroupContainerRunner的run()方法。 * 3、在run()方法内部执行this.taskGroupContainer.start()方法。 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">startAllTaskGroup</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>Configuration<span class="token operator">></span> configurations<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * 根据taskGroup的数量启动固定的线程数     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupContainerExecutorService <span class="token operator">=</span> Executors            <span class="token punctuation">.</span><span class="token function">newFixedThreadPool</span><span class="token punctuation">(</span>configurations<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * 每个taskGroup启动一个TaskGroupContainerRunner     */</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Configuration taskGroupConfiguration <span class="token operator">:</span> configurations<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * by 耳东陈         * 创建TaskGroupContainerRunner并提交线程池运行         */</span>        <span class="token comment" spellcheck="true">/**         * by 耳东陈         * 在TaskGroupContainerRunner的run()方法内部执行this.taskGroupContainer.start()方法。         */</span>        TaskGroupContainerRunner taskGroupContainerRunner <span class="token operator">=</span> <span class="token function">newTaskGroupContainerRunner</span><span class="token punctuation">(</span>taskGroupConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupContainerExecutorService<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>taskGroupContainerRunner<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * 等待所有任务执行完后会关闭，执行该方法后不会再接收新任务     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupContainerExecutorService<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="十二、TaskGroupContainer：分配的Task，创建并执行TaskExecutor；"><a href="#十二、TaskGroupContainer：分配的Task，创建并执行TaskExecutor；" class="headerlink" title="十二、TaskGroupContainer：分配的Task，创建并执行TaskExecutor；"></a>十二、TaskGroupContainer：分配的Task，创建并执行TaskExecutor；</h3><p>TaskGroupContainer的start方式是在上一步骤中执行<code>this.taskGroupContainerExecutorService.execute(taskGroupContainerRunner);</code>的时候会启动每个TaskGroupContainerRunner线程，在这个run方法里面会被调度起来<br>TaskGroupContainer的内部主要做的事情如下：</p><ol><li>根据TaskGroupContainer分配的Task任务列表，创建TaskExecutor对象。</li><li>创建TaskExecutor对象，用以启动分配该TaskGroup的task。</li><li>至此，已经成功的启动了Job当中的Task任务。</li></ol><p>核心逻辑在于while循环：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * by 耳东陈 *  下面实现主要分为以下几个步骤： *    循环检测所有任务的执行状态 *       1）判断是否有失败的task，如果有则放入失败对立中，并查看当前的执行是否支持重跑和failOver，如果支持则重新放回执行队列中；如果没有失败，则标记任务执行成功，并从状态轮询map中移除 *       2）如果发现有失败的任务，则汇报当前TaskGroup的状态，并抛出异常 *       3）查看当前执行队列的长度，如果发现执行队列还有通道，则构建TaskExecutor加入执行队列，并从待运行移除 *       4）检查执行队列和所有的任务状态，如果所有的任务都执行成功，则汇报taskGroup的状态并从循环中退出 *       5）检查当前时间是否超过汇报时间检测，如果是，则汇报当前状态 *       6）当所有的执行完成从while中退出之后，再次全局汇报当前的任务状态 */</span><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1.判断task状态</span>    <span class="token keyword">boolean</span> failedOrKilled <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Communication<span class="token operator">></span> communicationMap <span class="token operator">=</span> containerCommunicator<span class="token punctuation">.</span><span class="token function">getCommunicationMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Communication<span class="token operator">></span> entry <span class="token operator">:</span> communicationMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        Integer taskId <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Communication taskCommunication <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>taskCommunication<span class="token punctuation">.</span><span class="token function">isFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        TaskExecutor taskExecutor <span class="token operator">=</span> <span class="token function">removeTask</span><span class="token punctuation">(</span>runTasks<span class="token punctuation">,</span> taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//上面从runTasks里移除了，因此对应在monitor里移除</span>        taskMonitor<span class="token punctuation">.</span><span class="token function">removeTask</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//失败，看task是否支持failover，重试次数未超过最大限制</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>taskCommunication<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> State<span class="token punctuation">.</span>FAILED<span class="token punctuation">)</span><span class="token punctuation">{</span>            taskFailedExecutorMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>taskId<span class="token punctuation">,</span> taskExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>taskExecutor<span class="token punctuation">.</span><span class="token function">supportFailOver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> taskExecutor<span class="token punctuation">.</span><span class="token function">getAttemptCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> taskMaxRetryTimes<span class="token punctuation">)</span><span class="token punctuation">{</span>                taskExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//关闭老的executor</span>                containerCommunicator<span class="token punctuation">.</span><span class="token function">resetCommunication</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//将task的状态重置</span>                Configuration taskConfig <span class="token operator">=</span> taskConfigMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>                taskQueue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>taskConfig<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//重新加入任务列表</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                failedOrKilled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>taskCommunication<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> State<span class="token punctuation">.</span>KILLED<span class="token punctuation">)</span><span class="token punctuation">{</span>            failedOrKilled <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>taskCommunication<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> State<span class="token punctuation">.</span>SUCCEEDED<span class="token punctuation">)</span><span class="token punctuation">{</span>            Long taskStartTime <span class="token operator">=</span> taskStartTimeMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>taskStartTime <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                Long usedTime <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> taskStartTime<span class="token punctuation">;</span>                LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"taskGroup[{}] taskId[{}] is successed, used[{}]ms"</span><span class="token punctuation">,</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupId<span class="token punctuation">,</span> taskId<span class="token punctuation">,</span> usedTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">//usedTime*1000*1000 转换成PerfRecord记录的ns，这里主要是简单登记，进行最长任务的打印。因此增加特定静态方法</span>                PerfRecord<span class="token punctuation">.</span><span class="token function">addPerfRecord</span><span class="token punctuation">(</span>taskGroupId<span class="token punctuation">,</span> taskId<span class="token punctuation">,</span> PerfRecord<span class="token punctuation">.</span>PHASE<span class="token punctuation">.</span>TASK_TOTAL<span class="token punctuation">,</span>taskStartTime<span class="token punctuation">,</span> usedTime <span class="token operator">*</span> 1000L <span class="token operator">*</span> 1000L<span class="token punctuation">)</span><span class="token punctuation">;</span>                taskStartTimeMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>                taskConfigMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 2.发现该taskGroup下taskExecutor的总状态失败则汇报错误</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>failedOrKilled<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastTaskGroupContainerCommunication <span class="token operator">=</span> <span class="token function">reportTaskGroupCommunication</span><span class="token punctuation">(</span>                lastTaskGroupContainerCommunication<span class="token punctuation">,</span> taskCountInThisTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">throw</span> DataXException<span class="token punctuation">.</span><span class="token function">asDataXException</span><span class="token punctuation">(</span>                FrameworkErrorCode<span class="token punctuation">.</span>PLUGIN_RUNTIME_ERROR<span class="token punctuation">,</span> lastTaskGroupContainerCommunication<span class="token punctuation">.</span><span class="token function">getThrowable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//3.有任务未执行，且正在运行的任务数小于最大通道限制</span>    Iterator<span class="token operator">&lt;</span>Configuration<span class="token operator">></span> iterator <span class="token operator">=</span> taskQueue<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> runTasks<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> channelNumber<span class="token punctuation">)</span><span class="token punctuation">{</span>        Configuration taskConfig <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Integer taskId <span class="token operator">=</span> taskConfig<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>TASK_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> attemptCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        TaskExecutor lastExecutor <span class="token operator">=</span> taskFailedExecutorMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>lastExecutor<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            attemptCount <span class="token operator">=</span> lastExecutor<span class="token punctuation">.</span><span class="token function">getAttemptCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> now <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> failedTime <span class="token operator">=</span> lastExecutor<span class="token punctuation">.</span><span class="token function">getTimeStamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> failedTime <span class="token operator">&lt;</span> taskRetryIntervalInMsec<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//未到等待时间，继续留在队列</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>lastExecutor<span class="token punctuation">.</span><span class="token function">isShutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//上次失败的task仍未结束</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> failedTime <span class="token operator">></span> taskMaxWaitInMsec<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">markCommunicationFailed</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token function">reportTaskGroupCommunication</span><span class="token punctuation">(</span>lastTaskGroupContainerCommunication<span class="token punctuation">,</span> taskCountInThisTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">throw</span> DataXException<span class="token punctuation">.</span><span class="token function">asDataXException</span><span class="token punctuation">(</span>CommonErrorCode<span class="token punctuation">.</span>WAIT_TIME_EXCEED<span class="token punctuation">,</span> <span class="token string">"task failover等待超时"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    lastExecutor<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//再次尝试关闭</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"taskGroup[{}] taskId[{}] attemptCount[{}] has already shutdown"</span><span class="token punctuation">,</span>                        <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupId<span class="token punctuation">,</span> taskId<span class="token punctuation">,</span> lastExecutor<span class="token punctuation">.</span><span class="token function">getAttemptCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">/**         * by 耳东陈         * 需要新建任务的配置信息         */</span>        Configuration taskConfigForRun <span class="token operator">=</span> taskMaxRetryTimes <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> taskConfig<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> taskConfig<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * by 耳东陈         * taskExecutor应该就需要新建的任务         */</span>        TaskExecutor taskExecutor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TaskExecutor</span><span class="token punctuation">(</span>taskConfigForRun<span class="token punctuation">,</span> attemptCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        taskStartTimeMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>taskId<span class="token punctuation">,</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        taskExecutor<span class="token punctuation">.</span><span class="token function">doStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        runTasks<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>taskExecutor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//上面，增加task到runTasks列表，因此在monitor里注册。</span>        taskMonitor<span class="token punctuation">.</span><span class="token function">registerTask</span><span class="token punctuation">(</span>taskId<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>containerCommunicator<span class="token punctuation">.</span><span class="token function">getCommunication</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        taskFailedExecutorMap<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"taskGroup[{}] taskId[{}] attemptCount[{}] is started"</span><span class="token punctuation">,</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupId<span class="token punctuation">,</span> taskId<span class="token punctuation">,</span> attemptCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//4.任务列表为空，executor已结束, 搜集状态为success--->成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>taskQueue<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isAllTaskDone</span><span class="token punctuation">(</span>runTasks<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> containerCommunicator<span class="token punctuation">.</span><span class="token function">collectState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> State<span class="token punctuation">.</span>SUCCEEDED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 成功的情况下，也需要汇报一次。否则在任务结束非常快的情况下，采集的信息将会不准确</span>        lastTaskGroupContainerCommunication <span class="token operator">=</span> <span class="token function">reportTaskGroupCommunication</span><span class="token punctuation">(</span>                lastTaskGroupContainerCommunication<span class="token punctuation">,</span> taskCountInThisTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>        LOG<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"taskGroup[{}] completed it's tasks."</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskGroupId<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 5.如果当前时间已经超出汇报时间的interval，那么我们需要马上汇报</span>    <span class="token keyword">long</span> now <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> lastReportTimeStamp <span class="token operator">></span> reportIntervalInMillSec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        lastTaskGroupContainerCommunication <span class="token operator">=</span> <span class="token function">reportTaskGroupCommunication</span><span class="token punctuation">(</span>                lastTaskGroupContainerCommunication<span class="token punctuation">,</span> taskCountInThisTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>        lastReportTimeStamp <span class="token operator">=</span> now<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//taskMonitor对于正在运行的task，每reportIntervalInMillSec进行检查</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>TaskExecutor taskExecutor<span class="token operator">:</span>runTasks<span class="token punctuation">)</span><span class="token punctuation">{</span>            taskMonitor<span class="token punctuation">.</span><span class="token function">report</span><span class="token punctuation">(</span>taskExecutor<span class="token punctuation">.</span><span class="token function">getTaskId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">this</span><span class="token punctuation">.</span>containerCommunicator<span class="token punctuation">.</span><span class="token function">getCommunication</span><span class="token punctuation">(</span>taskExecutor<span class="token punctuation">.</span><span class="token function">getTaskId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span>sleepIntervalInMillSec<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//6.最后还要汇报一次</span><span class="token function">reportTaskGroupCommunication</span><span class="token punctuation">(</span>lastTaskGroupContainerCommunication<span class="token punctuation">,</span> taskCountInThisTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="十三、TaskExecutor：一个完整task的执行器；"><a href="#十三、TaskExecutor：一个完整task的执行器；" class="headerlink" title="十三、TaskExecutor：一个完整task的执行器；"></a>十三、TaskExecutor：一个完整task的执行器；</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * by 耳东陈 * 说明： * TaskExecutor是一个完整task的执行器 * TaskExecutor的启动过程主要做了以下事情： * * 1、创建了reader和writer的线程任务，reader和writer公用一个channel。 * 2、先启动writer线程后，再启动reader线程。 * 3、至此，同步数据的Task任务已经启动了。 */</span><span class="token keyword">public</span> <span class="token function">TaskExecutor</span><span class="token punctuation">(</span>Configuration taskConf<span class="token punctuation">,</span> <span class="token keyword">int</span> attemptCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取该taskExecutor的配置</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig <span class="token operator">=</span> taskConf<span class="token punctuation">;</span>    Validate<span class="token punctuation">.</span><span class="token function">isTrue</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>JOB_READER<span class="token punctuation">)</span>                    <span class="token operator">&amp;&amp;</span> null <span class="token operator">!=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig<span class="token punctuation">.</span><span class="token function">getConfiguration</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>JOB_WRITER<span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token string">"[reader|writer]的插件参数不能为空!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 得到taskId</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>taskId <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>CoreConstant<span class="token punctuation">.</span>TASK_ID<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>attemptCount <span class="token operator">=</span> attemptCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 由taskId得到该taskExecutor的Communication     * 要传给readerRunner和writerRunner，同时要传给channel作统计用     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>taskCommunication <span class="token operator">=</span> containerCommunicator            <span class="token punctuation">.</span><span class="token function">getCommunication</span><span class="token punctuation">(</span>taskId<span class="token punctuation">)</span><span class="token punctuation">;</span>    Validate<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>taskCommunication<span class="token punctuation">,</span>            String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"taskId[%d]的Communication没有注册过"</span><span class="token punctuation">,</span> taskId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>channel <span class="token operator">=</span> ClassUtil<span class="token punctuation">.</span><span class="token function">instantiate</span><span class="token punctuation">(</span>channelClazz<span class="token punctuation">,</span>            Channel<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * by 耳东陈     * channel在这里生成，每个taskGroup生成一个channel，     * 在generateRunner方法当中生成writer或reader并注入channel     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>channel<span class="token punctuation">.</span><span class="token function">setCommunication</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>taskCommunication<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取transformer的参数     */</span>    List<span class="token operator">&lt;</span>TransformerExecution<span class="token operator">></span> transformerInfoExecs <span class="token operator">=</span> TransformerUtil<span class="token punctuation">.</span><span class="token function">buildTransformerInfo</span><span class="token punctuation">(</span>taskConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 生成writerThread     */</span>    writerRunner <span class="token operator">=</span> <span class="token punctuation">(</span>WriterRunner<span class="token punctuation">)</span> <span class="token function">generateRunner</span><span class="token punctuation">(</span>PluginType<span class="token punctuation">.</span>WRITER<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>writerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>writerRunner<span class="token punctuation">,</span>            String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d-%d-%d-writer"</span><span class="token punctuation">,</span>                    jobId<span class="token punctuation">,</span> taskGroupId<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>writerThread<span class="token punctuation">.</span><span class="token function">setContextClassLoader</span><span class="token punctuation">(</span>LoadUtil<span class="token punctuation">.</span><span class="token function">getJarLoader</span><span class="token punctuation">(</span>            PluginType<span class="token punctuation">.</span>WRITER<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>                    CoreConstant<span class="token punctuation">.</span>JOB_WRITER_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 生成readerThread     */</span>    readerRunner <span class="token operator">=</span> <span class="token punctuation">(</span>ReaderRunner<span class="token punctuation">)</span> <span class="token function">generateRunner</span><span class="token punctuation">(</span>PluginType<span class="token punctuation">.</span>READER<span class="token punctuation">,</span>transformerInfoExecs<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>readerThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>readerRunner<span class="token punctuation">,</span>            String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%d-%d-%d-reader"</span><span class="token punctuation">,</span>                    jobId<span class="token punctuation">,</span> taskGroupId<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过设置thread的contextClassLoader，即可实现同步和主程序不通的加载器     */</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>readerThread<span class="token punctuation">.</span><span class="token function">setContextClassLoader</span><span class="token punctuation">(</span>LoadUtil<span class="token punctuation">.</span><span class="token function">getJarLoader</span><span class="token punctuation">(</span>            PluginType<span class="token punctuation">.</span>READER<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>taskConfig<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span>                    CoreConstant<span class="token punctuation">.</span>JOB_READER_NAME<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="十四、invokeHooks用法？"><a href="#十四、invokeHooks用法？" class="headerlink" title="十四、invokeHooks用法？"></a>十四、invokeHooks用法？</h3><p>目前发现DataX在运行的最后，调用了此方法，还没有搜到相关资料，记录一下日后更新。<br><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200428/14.1.png" align="left/"></p>]]></content>
      
      
      <categories>
          
          <category> DataX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DataX-使用idea调试DataX源码</title>
      <link href="/2020/04/27/DataX-%E4%BD%BF%E7%94%A8idea%E8%B0%83%E8%AF%95DataX%E6%BA%90%E7%A0%81/"/>
      <url>/2020/04/27/DataX-%E4%BD%BF%E7%94%A8idea%E8%B0%83%E8%AF%95DataX%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><p>使用idea调试DataX的源码；</p></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>jdk版本：1.8.0_202-b08；</li><li>Python版本：2.7.18（官方推荐2.6.X）；</li><li>Maven版本；3.6.0 ；</li><li>DataX是直接拉取的master分支上的源码；</li><li>准备好一个json文件；</li></ol></blockquote><h3 id="三、拉取源码在本机编译打包"><a href="#三、拉取源码在本机编译打包" class="headerlink" title="三、拉取源码在本机编译打包"></a>三、拉取源码在本机编译打包</h3><ol><li>用git直接克隆到本地：<a href="https://github.com/alibaba/DataX.git" target="_blank" rel="noopener">https://github.com/alibaba/DataX.git</a></li><li>通过maven打包：<pre><code>cd  {DataX_source_code_home}mvn -U clean package assembly:assembly -Dmaven.test.skip=true</code></pre>打包成功，日志显示如下：<pre><code>[INFO] BUILD SUCCESS[INFO] -----------------------------------------------------------------[INFO] Total time: 08:12 min[INFO] Finished at: 2015-12-13T16:26:48+08:00[INFO] Final Memory: 133M/960M[INFO] -----------------------------------------------------------------</code></pre><strong><font color="red">防坑</font></strong>：DataX工程里面配置的是阿里的maven镜像，打起包来相对较快，但是插件较多，也是要好几分的，<font color="red">另外打包的时候有的插件老是报错，可以多执行几遍maven打包命令，如果用不到那个插件可以先从父工程里面注释掉其引用。</font></li></ol><h3 id="四、用python执行DataX脚本"><a href="#四、用python执行DataX脚本" class="headerlink" title="四、用python执行DataX脚本"></a>四、用python执行DataX脚本</h3><p>起一个cmd窗口执行脚本</p><pre><code>E:\datax_source\DataX\target\datax\datax\bin\datax.py E:\datax_source\DataX\target\datax\datax\bin\debug.json -d</code></pre><p> 命令执行后如下图所示：<br> <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200427/4.1.png" align="left/"><br>  说明：</p><ol><li>datax.py脚本是打包成功后，在target目录下的那个文件</li><li>debug.json是用户配置同步的文件</li><li>-d 是运行debug模式</li><li>ip是本机的ip，端口9999是在datax.py脚本文件中，debug时的默认开放端口，可修改</li><li>此时，本机的这个端口已经开放了，等待程序调用</li></ol><h3 id="五、在idea中配置Remote"><a href="#五、在idea中配置Remote" class="headerlink" title="五、在idea中配置Remote"></a>五、在idea中配置Remote</h3> <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200427/5.1.png" align="left/"> 配置完成后，在DataX的主程序入口打个debug点（DataX的主程序入口在com.alibaba.datax.core.Engine类的main方法）： <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200427/5.2.png" align="left/"> 即可开始源码解析之旅！<h3 id="六、乱码解决"><a href="#六、乱码解决" class="headerlink" title="六、乱码解决"></a>六、乱码解决</h3><p> 在cmd窗口debug的时候，DataX打印的日志可能会有乱码，可以在命令行键入<code>chcp 65001</code>即可；这个方法只可以在该cmd窗口有效，下次再打开cmd窗口就失效了，可以修改注册表，来永久修改，方法自行百度。</p>]]></content>
      
      
      <categories>
          
          <category> DataX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下配置jdk环境</title>
      <link href="/2020/04/20/linux%E4%B8%8B%E9%85%8D%E7%BD%AEjdk%E7%8E%AF%E5%A2%83/"/>
      <url>/2020/04/20/linux%E4%B8%8B%E9%85%8D%E7%BD%AEjdk%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><p>3分钟配置好jdk环境</p></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>jdk版本为1.8.0_202；</li><li>linux系统：CentOS 7.4；</li></ol></blockquote><p>废话不多说，直接上命令</p><h3 id="三、下载jdk安装包"><a href="#三、下载jdk安装包" class="headerlink" title="三、下载jdk安装包"></a>三、下载jdk安装包</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 华为镜像，极速下载体验</span><span class="token function">wget</span> https://mirrors.huaweicloud.com/java/jdk/8u202-b08/jdk-8u202-linux-x64.tar.gz</code></pre><h3 id="四、解压"><a href="#四、解压" class="headerlink" title="四、解压"></a>四、解压</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -xzvf jdk-8u202-linux-x64.tar.gz -C /usr/local</code></pre><h3 id="五、配置环境变量"><a href="#五、配置环境变量" class="headerlink" title="五、配置环境变量"></a>五、配置环境变量</h3><pre><code># 文件末尾另起一行 追加如下内容JAVA_HOME=/usr/local/jdk1.8.0_202CLASSPATH=$JAVA_HOME/lib/PATH=$PATH:$JAVA_HOME/binexport PATH JAVA_HOME CLASSPATH</code></pre><h3 id="六、查询"><a href="#六、查询" class="headerlink" title="六、查询"></a>六、查询</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 更新配置</span><span class="token function">source</span> /etc/profile<span class="token comment" spellcheck="true"># 查看jdk版本</span>java -version</code></pre>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境配置 </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(六)-hive的安装和基本使用</title>
      <link href="/2020/03/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E5%85%AD)-hive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/03/17/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E5%85%AD)-hive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>前置环境、hive版本与部署服务器选择；</li><li>下载解压、修改配置文件；</li><li>配置环境变量；</li><li>下载mysql驱动包</li><li>启动hive；</li><li>创建数据库表，并导入数据到hdfs；</li><li>导入数据，进行hive查询；</li><li>hive内部使用到的mysql部分表说明；</li><li>hive启动为服务；</li><li>脚本化运行方式；</li><li>hive建库建表与数据导入；</li><li>内部表与外部表；</li><li>分区表；</li><li>CTAS建表语法；</li><li>数据导入导出；</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>hive的版本为3.1.2；</li><li>linux系统：CentOS 7.2；</li><li>需要mysql服务；</li><li>需要HDFS分布式文件系统；</li></ol></blockquote><h3 id="三、前置环境、hive版本与部署服务器选择"><a href="#三、前置环境、hive版本与部署服务器选择" class="headerlink" title="三、前置环境、hive版本与部署服务器选择"></a>三、前置环境、hive版本与部署服务器选择</h3><ol><li>hive的启动需要的环境：mysql、HDFS；</li><li>hive版本选择与下载：<a href="http://hive.apache.org/downloads.html" title="点击跳转" target="_blank" rel="noopener"><strong><font color="purple">点击跳转</font></strong></a>；</li><li>我的hive准备部署在master上（192.168.6.100）；</li></ol><h3 id="四、下载解压、修改配置文件"><a href="#四、下载解压、修改配置文件" class="headerlink" title="四、下载解压、修改配置文件"></a>四、下载解压、修改配置文件</h3><ol><li><p>解压 <code>tar -xzvf apache-hive-3.1.2-bin.tar.gz</code></p></li><li><p>在conf目录下新建配置文件hive-site.xml，配置如下内容：</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionURL<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>jdbc:mysql://192.168.6.102:3306/hive?createDatabaseIfNotExist=true<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>JDBC connect string for a JDBC metastore<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionDriverName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>com.mysql.jdbc.Driver<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>Driver class name for a JDBC metastore<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionUserName<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>root<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>username to use against metastore database<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>javax.jdo.option.ConnectionPassword<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>123456<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>password to use against metastore database<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span></code></pre></li></ol><h3 id="五、配置环境变量"><a href="#五、配置环境变量" class="headerlink" title="五、配置环境变量"></a>五、配置环境变量</h3><pre><code>HADOOP_HOME=/usr/local/hadoop-3.2.1HIVE_HOME=/usr/local/apache-hive-3.1.2-binPATH=$PATH:$JAVA_HOME/bin:$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$HIVE_HOME/binexport PATH JAVA_HOME HADOOP_HOME HIVE_HOME CLASSPATH</code></pre><p>环境变量配置是否成功：<code>hive --version</code></p><h3 id="六、下载mysql驱动包"><a href="#六、下载mysql驱动包" class="headerlink" title="六、下载mysql驱动包"></a>六、下载mysql驱动包</h3><p>下载mysql驱动包并放到hive家目录的lib目录中，<a href="http://staticfile.erdongchen.top/download/mysql-connector-java-5.1.48.jar" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">下载mysql驱动包</font></strong></a></p><h3 id="七、启动hive"><a href="#七、启动hive" class="headerlink" title="七、启动hive"></a>七、启动hive</h3><p>配置完hive的环境变量后可以直接使用命令启动：<code>hive</code><br><strong><font color="red">防坑</font></strong>：启动报错：</p><pre><code>    java.lang.NoSuchMethodError: com.google.common.base.Preconditions.checkArgument(ZLjava/lang/String;Ljava/lang/Object;)V</code></pre><p><strong><font color="green">解决方案</font></strong>：<br> 在hadoop安装目录hadoop\share\hadoop\common\lib和hive\lib目录下分别找到guava.jar，将最新版本的jar包覆盖到另一个目录</p><h3 id="八、创建数据库表，并导入数据到hdfs"><a href="#八、创建数据库表，并导入数据到hdfs" class="headerlink" title="八、创建数据库表，并导入数据到hdfs"></a>八、创建数据库表，并导入数据到hdfs</h3><p>配置完hive的环境变量后可以直接使用命令启动：<code>hive</code><br><strong><font color="red">防坑</font></strong>：执行Hql语句<code>show databases;</code>报错：</p><pre><code>    FAILED: HiveException java.lang.RuntimeException: Unable to instantiate org.apache.hadoop.hive.ql.metadata.SessionHiveMetaStoreClient</code></pre><p><strong><font color="green">解决方案</font></strong>：<br> 在hive家目录执行初始化mysql的hive库的命令：<code>bin/schematool -dbType mysql -initSchema</code><br> 如图所示：<br> <img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/8.1.jpg" align="left/"></p><ol><li>创建数据库：<br><code>create database myHive;</code></li><li>创建一张数据表(后面会说明hive创建语法)：<br><code>create table students(id int,name string,age int,sex string)row format delimited fields terminated by &#39;,&#39;;</code><br>这样就会在hdfs上建立一个数据目录：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/8.2.jpg" align="left/"></li></ol><h3 id="九、导入数据，进行hive查询"><a href="#九、导入数据，进行hive查询" class="headerlink" title="九、导入数据，进行hive查询"></a>九、导入数据，进行hive查询</h3><ol><li>新建一个文件，名为stu，并填充如下内容<pre><code>1,张三,18,男2,李四,12,女3,王五,45,男4,赵六,33,男5,周七,48,男6,陈8,,27,女</code></pre></li><li>将文件put到HDFS上的hive仓库中：<pre><code>hadoop fs -put stu /user/hive/warehouse/students</code></pre></li><li>在hive的命令窗口执行命令：<code>select * from students;</code>，会得到如图所示的结果：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/9.1.jpg" align="left/"></li><li>小技巧<br>在当前登录用户的家目录下新建一个文件.hiverc。并键入如下配置<pre><code># 让提示符显示当前库set hive.cli.print.header=true;# 显示查询结果时显示字段名称set hive.cli.print.current.db=true;</code></pre>然后重启hive，当再次查询时：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/9.2.jpg" align="left/"></li><li>分组聚合查询：<code>select sex,count(1) as number from students group by sex;</code><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/9.3.jpg" align="left/"></li></ol><h3 id="十、hive内部使用到的mysql部分表说明"><a href="#十、hive内部使用到的mysql部分表说明" class="headerlink" title="十、hive内部使用到的mysql部分表说明"></a>十、hive内部使用到的mysql部分表说明</h3><ol><li>这时我在新建一个表,便于观察：<pre><code>create table menu(id int,name string,parent_id int,url string)row format delimited fields terminated by &#39;,&#39;;</code></pre></li><li>部分表说明：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/10.1.jpg" align="left/"></li></ol><h3 id="十一、hive启动为服务"><a href="#十一、hive启动为服务" class="headerlink" title="十一、hive启动为服务"></a>十一、hive启动为服务</h3><ol><li>hive启动为服务(在master上执行)：<pre><code>nohup hiveserver2 1&gt;/dev/null 2&gt;&amp;1 &amp;</code></pre></li><li>启动成功后，可以在别的节点上用beeline去连接：<br><strong><font color="green">方式一</font></strong>： <code>bin/beeline</code>  回车，进入beeline的命令界面<br>输入命令连接hiveserver2:<br><code>beeline&gt; !connect jdbc:hive2://master:10000</code><br><strong><font color="green">方式二</font></strong>：直接连接：<code>bin/beeline -u jdbc:hive2://master:10000 -n root</code><br>效果如图所示：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/11.1.jpg" align="left/"></li></ol><p><strong><font color="red">防坑</font></strong>：beeline连接远程hive服务时报错：</p><pre><code>    Error: Could not open client transport with JDBC Uri: jdbc:hive2://master:10000: Failed to open new session: java.lang.RuntimeException: org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: root is not allowed to impersonate root (state=08S01,code=0)</code></pre><p><strong><font color="green">解决方案</font></strong>：在hadoop的配置文件core-site.xml增加如下配置，重启hdfs</p><pre><code>    &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.groups&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;    &lt;property&gt;        &lt;name&gt;hadoop.proxyuser.root.hosts&lt;/name&gt;        &lt;value&gt;*&lt;/value&gt;    &lt;/property&gt;</code></pre><h3 id="十二、脚本化运行方式"><a href="#十二、脚本化运行方式" class="headerlink" title="十二、脚本化运行方式"></a>十二、脚本化运行方式</h3><ol><li>脚本命令的运行方式：<br><code>hive -e &quot;select * from students&quot;</code><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/12.1.jpg" align="left/"></li><li>文件脚本的运行方式：<br><code>hive -f /usr/local/myHive.hql</code><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/12.2.jpg" align="left/"></li></ol><h3 id="十三、hive建库建表与数据导入"><a href="#十三、hive建库建表与数据导入" class="headerlink" title="十三、hive建库建表与数据导入"></a>十三、hive建库建表与数据导入</h3><ol><li>建库语法：<br><code>create database myHive2;</code><br>数据库建好后，在hdfs中会生成一个目录：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/13.1.jpg" align="left/"></li><li>建表语法：<br><code>use myHive;</code><br><code>create table t_order(id string,create_time string,amount float,uid string);</code><br>表建好后，会在所属的库目录中生成一个表目录<br>/user/hive/warehouse/myHive.db/t_order<br>只是，这样建表的话，hive会认为表数据文件中的字段分隔符为 ^A<br>正确的建表语句为：<br><code>create table t_order(id string,create_time string,amount float,uid string) row format delimited fields terminated by &#39;,&#39;;</code><br>这样就指定了，我们的表数据文件中的字段分隔符为 “,”</li><li>删除表<br><code>drop table t_order cascade;</code><br>删除表的效果是：<br>hive会从元数据库中清除关于这个表的信息；<br>hive还会从hdfs中删除这个表的表目录；</li></ol><h3 id="十四、内部表与外部表"><a href="#十四、内部表与外部表" class="headerlink" title="十四、内部表与外部表"></a>十四、内部表与外部表</h3><ul><li>内部表(MANAGED_TABLE)：表目录按照hive的规范来部署，位于hive的仓库目录/user/hive/warehouse中</li><li>外部表(EXTERNAL_TABLE)：表目录由建表用户自己指定<ul><li><code>create external table t_access1(ip string,url string,access_time string) row format delimited fields terminated by &#39;,&#39; location &#39;/access/log&#39;;</code></li></ul></li><li>外部表和内部表的特性差别：<ul><li>1、内部表的目录在hive的仓库目录中 VS 外部表的目录由用户指定</li><li>2、drop一个内部表时：hive会清除相关元数据，并删除表数据目录</li><li>3、drop一个外部表时：hive只会清除相关元数据；</li></ul></li><li>一个hive的数据仓库，最底层的表，一定是来自于外部系统，为了不影响外部系统的工作逻辑，在hive中可建external表来映射这些外部系统产生的数据目录；</li><li>然后，后续的etl操作，产生的各种表建议用内部表(managed_table)</li></ul><h3 id="十五、分区表"><a href="#十五、分区表" class="headerlink" title="十五、分区表"></a>十五、分区表</h3><ul><li><p>分区表的实质是：在表目录中为数据文件创建分区子目录，以便于在查询时，MR程序可以针对分区子目录中的数据进行处理，缩减读取数据的范围。<br>  比如，网站每天产生的浏览记录，浏览记录应该建一个表来存放，但是，有时候，我们可能只需要对某一天的浏览记录进行分析<br>  这时，就可以将这个表建为分区表，每天的数据导入其中的一个分区；<br>  当然，每日的分区目录，应该有一个目录名（分区字段）</p></li><li><p>一个分区字段的实例<br>  0、测试数据下载<br>  <a href="http://staticfile.erdongchen.top/download/2019-09-15.log" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">2019-09-15.log</font></strong></a><br>  <a href="http://staticfile.erdongchen.top/download/2019-09-16.log" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">2019-09-16.log</font></strong></a><br>  <a href="http://staticfile.erdongchen.top/download/2019-09-17.log" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">2019-09-17.log</font></strong></a></p><p>  1、创建带分区的表</p><pre><code>  create table t_access(ip string,url string,access_time string) partitioned by(dt string) row format delimited fields terminated by &#39;,&#39;;  注意：分区字段不能是表定义中的已存在字段</code></pre><p>  2、向分区中导入数据</p><pre><code>  load data local inpath &#39;/usr/local/2019-09-15.log&#39; into table t_access partition(dt=&#39;20190915&#39;);  load data local inpath &#39;/usr/local/2019-09-16.log&#39; into table t_access partition(dt=&#39;20190916&#39;);  load data local inpath &#39;/usr/local/2019-09-17.log&#39; into table t_access partition(dt=&#39;20190917&#39;);</code></pre><p>  3、针对分区数据进行查询</p><pre><code>  a、统计15号的总PV：  select count(*) from t_access where dt=&#39;20190915&#39;;  实质：就是将分区字段当成表字段来用，就可以使用where子句指定分区了  b、统计表中所有数据总的PV：  select count(*) from t_access;  实质：不指定分区条件即可</code></pre></li><li><p>效果如下：</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/15.1.png" align="left/"><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200317/15.2.png" align="left/"></li><li><p>多个分区字段示例<br>  1、建表：</p><pre><code>  create table t_partition(id int,name string,age int)partitioned by(department string,sex string,howold int) row format delimited fields terminated by &#39;,&#39;;</code></pre><p>  2、导数据：</p><pre><code>  load data local inpath &#39;/root/p1.dat&#39; into table t_partition partition(department=&#39;xiangsheng&#39;,sex=&#39;male&#39;,howold=20);</code></pre></li></ul><h3 id="十六、CTAS建表语法"><a href="#十六、CTAS建表语法" class="headerlink" title="十六、CTAS建表语法"></a>十六、CTAS建表语法</h3><ul><li>可以通过已存在表来建表：<br>  1、新建的t_user_2表结构定义与源表t_user一致，但是没有数据<pre><code>  create table t_user_2 like t_user;</code></pre>  2、在建表的同时插入数据<pre><code>  create table t_access_user as select ip,url from t_access;  t_access_user会根据select查询的字段来建表，同时将查询的结果插入新表中</code></pre></li></ul><h3 id="十七、数据导入导出"><a href="#十七、数据导入导出" class="headerlink" title="十七、数据导入导出"></a>十七、数据导入导出</h3><ul><li>方式1：手动：<ul><li>手动用hdfs命令，将文件放入表目录；</li></ul></li><li>方式2：在hive的交互式shell中用hive命令来导入本地数据到表目录<ul><li>hive&gt;load data local inpath ‘/root/order.data.2’ into table t_order;</li></ul></li><li>方式3：用hive命令导入hdfs中的数据文件到表目录<ul><li>hive&gt;load data inpath ‘/access.log.2019-09-16.log’ into table t_access partition(dt=’20190916’);</li></ul></li></ul><p>注意：导本地文件和导HDFS文件的区别：<br> 本地文件导入表：复制<br> hdfs文件导入表：移动</p><ul><li><p>将hive表中的数据导出到指定路径的文件<br>  1、将hive表中的数据导入HDFS的文件</p><pre><code>  insert overwrite directory &#39;/root/access-data&#39; row format delimited fields terminated by &#39;,&#39; select * from t_access;</code></pre><p>  2、将hive表中的数据导入本地磁盘文件</p><pre><code>  insert overwrite local directory &#39;/root/access-data&#39; row format delimited fields terminated by &#39;,&#39; select * from t_access limit 100000;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(五)-yarn的环境配置</title>
      <link href="/2020/03/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%BA%94)-yarn%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2020/03/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%BA%94)-yarn%E7%9A%84%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>yarn的快速理解；</li><li>yarn的安装位置解析；</li><li>yarn配置文件与启动；</li><li>yarn配置说明；</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>yarn是在hadoop安装包里面启动，所以版本跟hadoop的版本一致；</li><li>linux系统：CentOS 7.2；</li></ol></blockquote><h3 id="三、yarn的快速理解"><a href="#三、yarn的快速理解" class="headerlink" title="三、yarn的快速理解"></a>三、yarn的快速理解</h3><p>&#160; &#160;yarn是一个分布式程序的运行调度平台<br>&#160; &#160;yarn中有两大核心角色：</p><ol><li>主节点：<strong>Resource Manager</strong>  &#160;(<strong><font color="red">1</font></strong>台)<br>接受用户提交的分布式计算程序，并为其划分资源；管理、监控各个Node Manager上的资源情况，以便于均衡负载；<br>Resource Manager一般安装在一台专门的机器上</li><li>从节点：<strong>Node Manager</strong> &#160;(<strong><font color="red">N</font></strong>台)<br>管理它所在机器的运算资源（cpu + 内存）；负责接受Resource Manager分配的任务，创建容器、回收资源；<br>Node Manager应该与HDFS中的data node重叠在一起，Node Manager启动多少台是根据在<code>$HADOOP_HOME/etc/hadoop/workers</code> 里面配置的信息</li></ol><h3 id="四、yarn的安装位置解析"><a href="#四、yarn的安装位置解析" class="headerlink" title="四、yarn的安装位置解析"></a>四、yarn的安装位置解析</h3><p>&#160;&#160;yarn如3.2所述，在结合我的机器现有部署的程序，我的master启动的是NameNode、DataNode，slave1、slave2启动的是DataNode，所以yarn的NodeManager节点应该安装在master、slave1、slave2上，理论上ResourceManager应该单独一台服务器部署，但是在我这，我就把yarn的主节点安装在master，方便管理(主要是服务器不够用)<br>&#160;&#160;yarn最终yarn的部署方案如下：</p><table><thead><tr><th align="center">服务器</th><th align="center">部署yarn节点</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">Resource Manager、DataNode</td></tr><tr><td align="center">slave1</td><td align="center">DataNode</td></tr><tr><td align="center">slave2</td><td align="center">DataNode</td></tr></tbody></table><h3 id="五、yarn配置文件与启动"><a href="#五、yarn配置文件与启动" class="headerlink" title="五、yarn配置文件与启动"></a>五、yarn配置文件与启动</h3><ol><li><p>修改配置文件：编辑<code>$HADOOP_HOME/etc/hadoop/yarn-site.xml</code>，增加以下内容</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>yarn.resourcemanager.hostname<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>master<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>yarn.nodemanager.aux-services<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>mapreduce_shuffle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>yarn.nodemanager.resource.memory-mb<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>1024<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>yarn.nodemanager.resource.cpu-vcores<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre></li><li><p>保存好yarn-site.xml后，将该文件复制到slave1、slave2的目录下：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#复制到slave1</span><span class="token function">scp</span> /usr/local/hadoop-3.2.1/etc/hadoop/yarn-site.xml root@slave1:/usr/local/hadoop-3.2.1/etc/hadoop/<span class="token comment" spellcheck="true">#复制到slave2</span><span class="token function">scp</span> /usr/local/hadoop-3.2.1/etc/hadoop/yarn-site.xml root@slave2:/usr/local/hadoop-3.2.1/etc/hadoop/</code></pre></li><li><p>启动yarn：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#随便那台机器上执行：</span><span class="token variable">$HADOOP_HOME</span>/sbin/start-yarn.sh</code></pre></li></ol><h3 id="六、yarn配置说明"><a href="#六、yarn配置说明" class="headerlink" title="六、yarn配置说明"></a>六、yarn配置说明</h3><ol><li><p>关于Node Manager启动的数量是跟文件workers里面配置的信息相关；</p></li><li><p>Resource Manager节点则是在配置文件中yarn.resourcemanager.hostname配置项相关；</p></li><li><p>默认的为Node Manager分配的运行内存是8G，配置项是yarn.nodemanager.resource.memory-mb，这个参数要根据实际机器的性能进行变换；</p></li><li><p>默认的为Node Manager分配的逻辑cpu是8核，配置项是yarn.nodemanager.resource.cpu-vcores</p></li><li><p>默认的web访问端口是8088，比如我的yarn启动后，页面访问路径是：<code>http://192.168.6.100:8088</code>可通过如下配置进行修改：</p><pre class=" language-xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>yarn.resourcemanager.webapp.address<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>${yarn.resourcemanager.hostname}:8089<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre></li><li><p>yarn的配置项的详细说明在如下地方：</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200308/6.1.png" align="left/"><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20200308/6.2.png" align="left/"></li><li><p>yarn的官方配置文档：hadoop官方网站：<a href="https://hadoop.apache.org/docs/stable/hadoop-yarn/hadoop-yarn-common/yarn-default.xml" title="yarn" target="_blank" rel="noopener"><strong>yarn官方配置文档</strong></a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> yarn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(四)-安装mysql</title>
      <link href="/2020/03/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E5%9B%9B)-%E5%AE%89%E8%A3%85mysql/"/>
      <url>/2020/03/05/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E5%9B%9B)-%E5%AE%89%E8%A3%85mysql/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><blockquote><ol><li>准备mysql安装包；</li><li>创建mysql用户和组；</li><li>解压安装包；</li><li>配置my.cnf；</li><li>修改当前目录拥有者为mysql用户；</li><li>mysql初始化；</li><li>复制启动脚本到资源目录；</li><li>配置环境变量；</li><li>启动mysql服务；</li><li>登录mysql 修改密码；</li><li>开启远程访问；</li><li>将mysqld服务加入到系统服务（开机自启）；</li></ol></blockquote><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><blockquote><ol><li>mysql版本：mysql-5.6.39；</li><li>linux系统：CentOS 7.2；</li><li>mysql我是安装在slave2(192.168.6.102)上，mysql只是作为hive内部使用，装在哪里都可以；</li></ol></blockquote><h3 id="三、准备mysql安装包"><a href="#三、准备mysql安装包" class="headerlink" title="三、准备mysql安装包"></a>三、准备mysql安装包</h3><p>&#160; &#160;<a href="https://pan.baidu.com/s/1TMCOOBR6shKot0sOHYa_hA" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">百度网盘下载mysql-5.6.39-linux-glibc2.12-x86_64</font></strong></a><br>&#160; &#160;提取码：4i3m</p><h3 id="四、创建mysql用户和组"><a href="#四、创建mysql用户和组" class="headerlink" title="四、创建mysql用户和组"></a>四、创建mysql用户和组</h3><p>执行以下命令来创建mysql用户组</p><pre class=" language-bash"><code class="language-bash"><span class="token function">groupadd</span> mysql</code></pre><p>执行以下命令来创建一个用户名为mysql的用户并加入mysql用户组</p><pre class=" language-bash"><code class="language-bash"><span class="token function">useradd</span> -g mysql mysql</code></pre><h3 id="五、解压安装包"><a href="#五、解压安装包" class="headerlink" title="五、解压安装包"></a>五、解压安装包</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -xzvf mysql-5.6.39-linux-glibc2.12-x86_64.tar.gz -C /usr/local/</code></pre><h3 id="六、创建并配置my-cnf"><a href="#六、创建并配置my-cnf" class="headerlink" title="六、创建并配置my.cnf"></a>六、创建并配置my.cnf</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">touch</span> /etc/my.cnf <span class="token operator">&amp;&amp;</span> vim /etc/my.cnf<span class="token comment" spellcheck="true"># 将下面这一段编辑到my.cnf文件中</span></code></pre><pre class=" language-txt"><code class="language-txt">[mysql]# 设置mysql客户端默认字符集default-character-set=utf8socket=/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/data/mysql.sock[mysqld]#设置3306端口port=3306socket=/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/data/mysql.sock# 设置mysql的安装目录basedir=/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64# 设置mysql数据库的数据的存放目录datadir=/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/data# 允许最大连接数max_connections=20# 服务端使用的字符集默认为8比特编码的latin1字符集character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODBlower_case_table_names=1max_allowed_packet=16M[client]socket=/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/data/mysql.sock</code></pre><h3 id="七、修改当前目录拥有者为mysql用户"><a href="#七、修改当前目录拥有者为mysql用户" class="headerlink" title="七、修改当前目录拥有者为mysql用户"></a>七、修改当前目录拥有者为mysql用户</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cd</span> /usr/local/mysql-5.6.39-linux-glibc2.12-x86_64<span class="token function">chown</span> -R mysql:mysql /usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/</code></pre><h3 id="八、mysql初始化"><a href="#八、mysql初始化" class="headerlink" title="八、mysql初始化"></a>八、mysql初始化</h3><p>&#160;&#160;如果是mysql5.6 初始化命令是  </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 我安装的是5.6，所以执行这一句</span>./scripts/mysql_install_db --user<span class="token operator">=</span>mysql</code></pre><p>&#160;&#160;mysql5.6初始化时会<font color="red">报错</font>：</p><pre class=" language-bash"><code class="language-bash">FATAL ERROR: please <span class="token function">install</span> the following Perl modules before executing ./scripts/mysql_install_db:Data::Dumper</code></pre><p>&#160;&#160;<font color="green">解决方案：</font><br>&#160;&#160;安装autoconf库，命令：</p><pre class=" language-bash"><code class="language-bash">yum <span class="token function">install</span> -y autoconf   //此包安装时会安装Data:Dumper模块</code></pre><p>&#160;&#160;安装完了之后在执行 <code>./scripts/mysql_install_db --user=mysql</code></p><p>&#160;&#160;如果是mysql5.7 初始化命令是  </p><pre class=" language-bash"><code class="language-bash">bin/mysqld --user<span class="token operator">=</span>mysql --initialize</code></pre><h3 id="九、复制启动脚本到资源目录"><a href="#九、复制启动脚本到资源目录" class="headerlink" title="九、复制启动脚本到资源目录"></a>九、复制启动脚本到资源目录</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> ./support-files/mysql.server /etc/rc.d/init.d/mysqld</code></pre><h3 id="十、配置环境变量"><a href="#十、配置环境变量" class="headerlink" title="十、配置环境变量"></a>十、配置环境变量</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#将mysql的bin目录加入PATH环境变量</span><span class="token comment" spellcheck="true">#编辑/etc/profile文件</span>vim /etc/profile<span class="token comment" spellcheck="true">#在文件最后添加如下信息：</span><span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span>:/usr/local/mysql-5.6.39-linux-glibc2.12-x86_64/bin<span class="token comment" spellcheck="true">#执行下面的命令使所做的更改生效：</span><span class="token function">source</span> /etc/profile</code></pre><h3 id="十一、启动mysql服务"><a href="#十一、启动mysql服务" class="headerlink" title="十一、启动mysql服务"></a>十一、启动mysql服务</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">service</span> mysqld start</code></pre><h3 id="十二、登录mysql-修改密码"><a href="#十二、登录mysql-修改密码" class="headerlink" title="十二、登录mysql 修改密码"></a>十二、登录mysql 修改密码</h3><pre class=" language-bash"><code class="language-bash">mysql -u root</code></pre><p>&#160;&#160;进入到mysql命令窗口后逐条执行以下命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#切换database</span>mysql<span class="token operator">></span> use mysql<span class="token punctuation">;</span><span class="token comment" spellcheck="true">#修改密码为123456</span>mysql<span class="token operator">></span> UPDATE user SET Password<span class="token operator">=</span>PASSWORD<span class="token punctuation">(</span><span class="token string">'123456'</span><span class="token punctuation">)</span> where USER<span class="token operator">=</span><span class="token string">'root'</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">#刷新权限  </span>mysql<span class="token operator">></span> FLUSH PRIVILEGES<span class="token punctuation">;</span> </code></pre><h3 id="十三、开启远程访问"><a href="#十三、开启远程访问" class="headerlink" title="十三、开启远程访问"></a>十三、开启远程访问</h3><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#mysql命令行执行：开启远程访问（默认mysql是不开启远程访问）</span>mysql<span class="token operator">></span> grant all privileges on *.* to <span class="token string">'root'</span>@<span class="token string">'%'</span> identified by <span class="token string">'123456'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">#本句命令含义：远程访问用户为root，用户权限为全部database的全部操作类型（crud），远程密码为123456，本地登录密码和远程访问用户的密码可以不同</span></code></pre><h3 id="十四、将mysqld服务加入到系统服务（开机自启）"><a href="#十四、将mysqld服务加入到系统服务（开机自启）" class="headerlink" title="十四、将mysqld服务加入到系统服务（开机自启）"></a>十四、将mysqld服务加入到系统服务（开机自启）</h3><pre class=" language-bash"><code class="language-bash"><span class="token function">chkconfig</span> --add mysqld</code></pre><p>&#160;&#160;检查mysqld服务是否已经生效</p><pre class=" language-bash"><code class="language-bash"><span class="token function">chkconfig</span> --list mysqld</code></pre><p>&#160;&#160;命令输出类似下面的结果：<br>&#160;&#160;<font color="green">mysqld 0:off 1:off 2:on 3:on 4:on 5:on 6:off</font><br>&#160;&#160;表明mysqld服务已经生效，在2、3、4、5运行级别随系统启动而自动启动，以后可以使用service命令控制mysql的启动和停止。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data JPA 学习总结与实战(二)-常用注解详解</title>
      <link href="/2020/01/10/Spring-Data-JPA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98(%E4%BA%8C)-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/10/Spring-Data-JPA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98(%E4%BA%8C)-%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>注解式查询；</li><li>@Entity实例里面基础注解；</li><li>关联关系注解；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>所用技术及软件同上篇；</li><li>本篇主要围绕Spring Data JPA里面常用注解进行三方面的总结；</li></ol><h3 id="三、注解式查询；"><a href="#三、注解式查询；" class="headerlink" title="三、注解式查询；"></a>三、注解式查询；</h3><h3 id="四、-Entity实例里面基础注解；"><a href="#四、-Entity实例里面基础注解；" class="headerlink" title="四、@Entity实例里面基础注解；"></a>四、@Entity实例里面基础注解；</h3><h3 id="五、关联关系注解；"><a href="#五、关联关系注解；" class="headerlink" title="五、关联关系注解；"></a>五、关联关系注解；</h3>]]></content>
      
      
      <categories>
          
          <category> Spring Data JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring全家桶 </tag>
            
            <tag> 框架 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data JPA 学习总结与实战(一)-接口源码详解</title>
      <link href="/2020/01/09/Spring-Data-JPA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98(%E4%B8%80)-%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/01/09/Spring-Data-JPA-%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%E4%B8%8E%E5%AE%9E%E6%88%98(%E4%B8%80)-%E6%8E%A5%E5%8F%A3%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><ol><li>在17年的时候，我参与了一个项目用的就是spring data jpa，那时候对hebernate不是很了解（因为我一直都是用的mybatis），稀里糊涂的做着需求，好在spring data jpa入门还是很容易的，特别的简单查询，就这样在百度中参与进那个项目的开发中；现在刚好有点时间可以学一学，就总结一下我的学习成果。</li><li>本系列文章是我在学习了《Spring data JPA从入门到精通》之后的总结；最后一篇系列文章将会有我写的例子作为实战，来检验一下自己的学习成果。</li><li><a href="http://staticfile.erdongchen.top/download/Spring-Data-JPA从入门到精通.pdf?n=Spring_data_JPA从入门到精通.pdf" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">《Spring data JPA从入门到精通》电子书下载</font></strong></a></li></ol><h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>顶级接口Repostitory介绍及层级关系；</li><li>CrudRepository接口方法详解；</li><li>PagingAndSortingRepository接口方法详解；</li><li>JpaRepository接口方法详解；</li><li>Repository的实现类SimpleJpaRepository介绍；</li><li>自定义查询方法命名规则；</li><li>查询方法关键字；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>spring boot 版本：2.1.1.RELEASE；</li><li>Spring Data JPA 版本：2.1.3.RELEASE；</li><li>IntelliJ IDEA 2019.1.1</li></ol><h3 id="三、顶级接口Repostitory介绍及层级关系"><a href="#三、顶级接口Repostitory介绍及层级关系" class="headerlink" title="三、顶级接口Repostitory介绍及层级关系"></a>三、顶级接口Repostitory介绍及层级关系</h3><ol><li><p>首先要知道jpa是一种规范，hebernate是jpa的一种实现，Spring Data JPA底层用的还是hebernate，Spring Data JPA 是Spring Data的一个子项目。它依赖了Spring Data Common包,而接口Repostitory也是位于Spring Data Common的lib里面的，是Spring Data里面做数据库操作的最底层的抽象接口、 最顶级的父类， 源码里面其实什么方法都没有， 仅仅起到一个标识作用。<br>Repostitory的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Indexed<span class="token punctuation">;</span><span class="token annotation punctuation">@Indexed</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Repository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre></li><li><p>我们可以利用Idea来查看Repostitory的层级关系，具体如下：<br>①. 打开Repository.class，该接口位于org.springframework.data.repository包下；<br>②. 快捷键Ctrl+H，如图所示：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200109/3.1.png" align="left/"></li></ol><h3 id="四、CrudRepository接口方法详解"><a href="#四、CrudRepository接口方法详解" class="headerlink" title="四、CrudRepository接口方法详解"></a>四、CrudRepository接口方法详解</h3><ol><li><p>CrudRepository的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Optional<span class="token punctuation">;</span><span class="token annotation punctuation">@NoRepositoryBean</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CrudRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">Repository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> S <span class="token function">save</span><span class="token punctuation">(</span>S entity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> Iterable<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">saveAll</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>S<span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//批量保存</span> Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findById</span><span class="token punctuation">(</span>ID id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">boolean</span> <span class="token function">existsById</span><span class="token punctuation">(</span>ID id<span class="token punctuation">)</span><span class="token punctuation">;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAllById</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>ID<span class="token operator">></span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">long</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//计算对象总个数</span> <span class="token keyword">void</span> <span class="token function">deleteById</span><span class="token punctuation">(</span>ID id<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">delete</span><span class="token punctuation">(</span>T entity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">deleteAll</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">void</span> <span class="token function">deleteAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>该接口主要是完成一些增删改查的操作，例如查看save(S entity)方法的具体实现，快捷键Ctrl+Alt+鼠标点击方法名save；可以看到底层实现（实现类是SimpleJpaRepository）：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Transactional</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> S <span class="token function">save</span><span class="token punctuation">(</span>S entity<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>entityInformation<span class="token punctuation">.</span><span class="token function">isNew</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      em<span class="token punctuation">.</span><span class="token function">persist</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> entity<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> em<span class="token punctuation">.</span><span class="token function">merge</span><span class="token punctuation">(</span>entity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>我们发现它是先检查传进去的实体是不是存在， 然后判断是新增还是更新； 是不是存在两种根据机制， 一种是根据主键来判断， 另一种是根据Version来判断。如果我们去看JPA控制台打印出来的SQL， 最少会有两条， 一条是查询， 一条是insert或者update。类似的删除方法也是一样的，程序会先判断存不存在，再去删除，所以这里特别强调一下delete和save方法， 因为在实际工作中有的人会画蛇添足， 自己先去查询再做判断处理， 其实Spring JPA底层都已经考虑到了。</p></li></ol><h3 id="五、PagingAndSortingRepository接口方法详解"><a href="#五、PagingAndSortingRepository接口方法详解" class="headerlink" title="五、PagingAndSortingRepository接口方法详解"></a>五、PagingAndSortingRepository接口方法详解</h3><ol><li><p>话不多说，先上源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Page<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Pageable<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Sort<span class="token punctuation">;</span><span class="token annotation punctuation">@NoRepositoryBean</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PagingAndSortingRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">CrudRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token punctuation">{</span> Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Sort sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//排序</span> Page<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Pageable pageable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分页并排序</span><span class="token punctuation">}</span></code></pre></li><li><p>findAll(Pageable pageable)方法根据分页和排序进行查询， 并用Page对象封装。 Pageable对象包含分页和Sort对象。PagingAndSortingRepository和CrudRepository都是Spring Data   Common的标准接口， 如果我们采用JPA， 那它对应的实现类就是Spring Data JPA的model里面的SimpleJpaRepository。</p></li></ol><h3 id="六、JpaRepository接口方法详解"><a href="#六、JpaRepository接口方法详解" class="headerlink" title="六、JpaRepository接口方法详解"></a>六、JpaRepository接口方法详解</h3><ol><li><p>JpaRepository源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>jpa<span class="token punctuation">.</span>repository<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>persistence<span class="token punctuation">.</span>EntityManager<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Example<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>domain<span class="token punctuation">.</span>Sort<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>NoRepositoryBean<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>PagingAndSortingRepository<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>data<span class="token punctuation">.</span>repository<span class="token punctuation">.</span>query<span class="token punctuation">.</span>QueryByExampleExecutor<span class="token punctuation">;</span><span class="token annotation punctuation">@NoRepositoryBean</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">JpaRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">PagingAndSortingRepository</span><span class="token operator">&lt;</span>T<span class="token punctuation">,</span> ID<span class="token operator">></span><span class="token punctuation">,</span> QueryByExampleExecutor<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>  List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Sort sort<span class="token punctuation">)</span><span class="token punctuation">;</span>  List<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">findAllById</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>ID<span class="token operator">></span> ids<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">saveAll</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>S<span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//强制缓存与数据库同步</span>  <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> S <span class="token function">saveAndFlush</span><span class="token punctuation">(</span>S entity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">void</span> <span class="token function">deleteInBatch</span><span class="token punctuation">(</span>Iterable<span class="token operator">&lt;</span>T<span class="token operator">></span> entities<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存并强制同步数据库</span>  <span class="token keyword">void</span> <span class="token function">deleteAllInBatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  T <span class="token function">getOne</span><span class="token punctuation">(</span>ID id<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Example<span class="token operator">&lt;</span>S<span class="token operator">></span> example<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据实例查询</span>  <span class="token annotation punctuation">@Override</span>  <span class="token operator">&lt;</span>S <span class="token keyword">extends</span> <span class="token class-name">T</span><span class="token operator">></span> List<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">findAll</span><span class="token punctuation">(</span>Example<span class="token operator">&lt;</span>S<span class="token operator">></span> example<span class="token punctuation">,</span> Sort sort<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据实例查询并排序</span><span class="token punctuation">}</span></code></pre></li><li><p>通过源码和CrudRepository相比较， 它支持Query By Example，批量删除， 提高删除效率， 手动刷新数据库的更改方法， 并将默认实现的查询结果变成了List。</p></li></ol><h3 id="七、Repository的实现类SimpleJpaRepository介绍"><a href="#七、Repository的实现类SimpleJpaRepository介绍" class="headerlink" title="七、Repository的实现类SimpleJpaRepository介绍"></a>七、Repository的实现类SimpleJpaRepository介绍</h3><ol><li>源码太多了，略过；首先看一下SimpleJpaRepository的类构图<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20200109/7.1.png" align="left/"></li><li>①. SimpleJpaRepository实现了JpaRepositoryImplementation接口，它是CrudRepository的默认实现；它的构造器都要求传入EntityManager<br>②. 它的类上注解了@Transactional(readOnly = true)；而对deleteById、delete、deleteAll、deleteInBatch、deleteAllInBatch、save、saveAndFlush、saveAll、flush都添加了@Transactional注解<br>③. 从各个方法的实现可以看到SimpleJpaRepository是使用EntityManager来完成具体的方法功能，对于查询功能很多都借助了applySpecificationToCriteria方法，将spring data的Specification转换为javax.persistence的CriteriaQuery</li></ol><h3 id="八、自定义查询方法命名规则；"><a href="#八、自定义查询方法命名规则；" class="headerlink" title="八、自定义查询方法命名规则；"></a>八、自定义查询方法命名规则；</h3><ol><li>主要接口看完了，除了上述接口中自带的方法外，日常开发中还需用到其他的查询，如根据名称查询，模糊查询，日期区间查询等等，具体如下：</li><li>例如我有个业务接口叫StudentRepository继承自JpaRepository接口；那么我就可以在这个业务接口里面定义一个方法<code>List&lt;Student&gt; findByNameLike(String name);</code>，按照一定的规则去命名接口，Spring Data JPA 就会自动根据方法名称去生成sql，返回数据，怎么样？很吊吧？</li><li>查看org.springframework.data.repository.query.parser.PartTree源码可以看到，Spring Data JPA 在解析业务接口的时候不光是find能解析成查询语句，还有read|get|query|stream都可以作为前缀<pre class=" language-java"><code class="language-java"> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String QUERY_PATTERN <span class="token operator">=</span> <span class="token string">"find|read|get|query|stream"</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String COUNT_PATTERN <span class="token operator">=</span> <span class="token string">"count"</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String EXISTS_PATTERN <span class="token operator">=</span> <span class="token string">"exists"</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String DELETE_PATTERN <span class="token operator">=</span> <span class="token string">"delete|remove"</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="九、查询方法关键字；"><a href="#九、查询方法关键字；" class="headerlink" title="九、查询方法关键字；"></a>九、查询方法关键字；</h3><p> 最后附上一份接口方法命名规则：</p><table><thead><tr><th align="center">序号</th><th align="center">关键字</th><th align="center">SQL符号</th><th align="center">方法命名样例</th><th align="center">对应JPQL语句片段</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">And</td><td align="center">and</td><td align="center">findByLastnameAndFirstname</td><td align="center">… where x.lastname = ?1 and x.firstname = ?2</td></tr><tr><td align="center">2</td><td align="center">Or</td><td align="center">or</td><td align="center">findByLastnameOrFirstname</td><td align="center">… where x.lastname = ?1 or x.firstname = ?2</td></tr><tr><td align="center">3</td><td align="center">Is,Equals</td><td align="center">=</td><td align="center">findByFirstname,findByFirstnameIs</td><td align="center">… where x.firstname = ?1</td></tr><tr><td align="center">4</td><td align="center">Between</td><td align="center">between xxx and xxx</td><td align="center">findByStartDateBetween</td><td align="center">… where x.startDate between ?1 and ?2</td></tr><tr><td align="center">5</td><td align="center">LessThan</td><td align="center">&lt;</td><td align="center">findByAgeLessThan</td><td align="center">… where x.age &lt; ?1</td></tr><tr><td align="center">6</td><td align="center">LessThanEqual</td><td align="center">&lt;=</td><td align="center">findByAgeLessThanEqual</td><td align="center">… where x.age &lt;= ?1</td></tr><tr><td align="center">7</td><td align="center">GreaterThan</td><td align="center">&gt;</td><td align="center">findByAgeGreaterThan</td><td align="center">… where x.age &gt; ?1</td></tr><tr><td align="center">8</td><td align="center">GreaterThanEqual</td><td align="center">&gt;=</td><td align="center">findByAgeGreaterThanEqual</td><td align="center">… where x.age &gt;= ?1</td></tr><tr><td align="center">9</td><td align="center">After</td><td align="center">&gt;</td><td align="center">findByStartDateAfter</td><td align="center">… where x.startDate &gt; ?1</td></tr><tr><td align="center">10</td><td align="center">Before</td><td align="center">&lt;</td><td align="center">findByStartDateBefore</td><td align="center">… where x.startDate &lt; ?1</td></tr><tr><td align="center">11</td><td align="center">IsNull</td><td align="center">is null</td><td align="center">findByAgeIsNull</td><td align="center">… where x.age is null</td></tr><tr><td align="center">12</td><td align="center">IsNotNull,NotNull</td><td align="center">is not null</td><td align="center">findByAge(Is)NotNull</td><td align="center">… where x.age not null</td></tr><tr><td align="center">13</td><td align="center">Like</td><td align="center">like</td><td align="center">findByFirstnameLike</td><td align="center">… where x.firstname like ?1</td></tr><tr><td align="center">14</td><td align="center">NotLike</td><td align="center">not like</td><td align="center">findByFirstnameNotLike</td><td align="center">… where x.firstname not like ?1</td></tr><tr><td align="center">15</td><td align="center">StartingWith</td><td align="center">like ‘xxx%’</td><td align="center">findByFirstnameStartingWith</td><td align="center">… where x.firstname like ?1(parameter bound with appended %)</td></tr><tr><td align="center">16</td><td align="center">EndingWith</td><td align="center">like ‘xxx%’</td><td align="center">findByFirstnameEndingWith</td><td align="center">… where x.firstname like ?1(parameter bound with prepended %)</td></tr><tr><td align="center">17</td><td align="center">Containing</td><td align="center">like ‘%xxx%’</td><td align="center">findByFirstnameContaining</td><td align="center">… where x.firstname like ?1(parameter bound wrapped in %)</td></tr><tr><td align="center">18</td><td align="center">OrderBy</td><td align="center">order by</td><td align="center">findByAgeOrderByLastnameDesc</td><td align="center">… where x.age = ?1 order by x.lastname desc</td></tr><tr><td align="center">19</td><td align="center">Not</td><td align="center">&lt;&gt;</td><td align="center">findByLastnameNot</td><td align="center">… where x.lastname &lt;&gt; ?1</td></tr><tr><td align="center">20</td><td align="center">In</td><td align="center">in()</td><td align="center">findByAgeIn(Collection<age> ages)</age></td><td align="center">… where x.age in ?1</td></tr><tr><td align="center">21</td><td align="center">NotIn</td><td align="center">not in()</td><td align="center">findByAgeNotIn(Collection<age> ages)</age></td><td align="center">… where x.age not in ?1</td></tr><tr><td align="center">22</td><td align="center">TRUE</td><td align="center">=true</td><td align="center">findByActiveTrue()</td><td align="center">… where x.active = true</td></tr><tr><td align="center">23</td><td align="center">FALSE</td><td align="center">=false</td><td align="center">findByActiveFalse()</td><td align="center">… where x.active = false</td></tr><tr><td align="center">24</td><td align="center">IgnoreCase</td><td align="center">upper(xxx)=upper(yyyy)</td><td align="center">findByFirstnameIgnoreCase</td><td align="center">… where UPPER(x.firstame) = UPPER(?1)</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Spring Data JPA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring全家桶 </tag>
            
            <tag> 框架 </tag>
            
            <tag> 总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(三)-分布式ZooKeeper的集群搭建</title>
      <link href="/2019/11/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%B8%89)-%E5%88%86%E5%B8%83%E5%BC%8FZooKeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/"/>
      <url>/2019/11/27/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%B8%89)-%E5%88%86%E5%B8%83%E5%BC%8FZooKeeper%E7%9A%84%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>机器准备； </li><li>zoo.cfg文件配置；</li><li>集群操作； </li><li>zk常用命令；</li><li>zk选举机制；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>沿用第一篇大数据教程中的环境及软件；</li><li>ZooKeeper安装包版本为：3.5.6</li></ol><h3 id="三、机器准备"><a href="#三、机器准备" class="headerlink" title="三、机器准备"></a>三、机器准备</h3><p>按照第一篇的集群规划，将在slave3、slave4、slave5上部署zk集群</p><ol><li>这三台机器上下载zk安装包：<pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/zookeeper-3.5.6/apache-zookeeper-3.5.6-bin.tar.gz</code></pre></li><li>解压并改名<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 解压</span><span class="token function">tar</span> -xzvf apache-zookeeper-3.5.6-bin.tar.gz -C /usr/local<span class="token comment" spellcheck="true">#改名（有强迫症）</span><span class="token function">mv</span> apache-zookeeper-3.5.6-bin zookeeper-3.5.6</code></pre></li></ol><h3 id="四、zoo-cfg文件配置"><a href="#四、zoo-cfg文件配置" class="headerlink" title="四、zoo.cfg文件配置"></a>四、zoo.cfg文件配置</h3><ol><li><p>zk集群运行需要存储数据到磁盘目录，在zookeeper-3.5.6目录下新建一个目录</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在/usr/local/zookeeper-3.5.6 目录下执行</span><span class="token function">mkdir</span> zkDataDir</code></pre></li><li><p>将conf目录下的zoo_sample.cfg文件复制一份，并重命名为zoo.cfg</p><pre class=" language-bash"><code class="language-bash"><span class="token function">cp</span> zoo_sample.cfg zoo.cfg</code></pre></li><li><p>我的配置文件示例</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># The number of milliseconds of each tick</span>tickTime<span class="token operator">=</span>2000<span class="token comment" spellcheck="true"># The number of ticks that the initial </span><span class="token comment" spellcheck="true"># synchronization phase can take</span>initLimit<span class="token operator">=</span>10<span class="token comment" spellcheck="true"># The number of ticks that can pass between </span><span class="token comment" spellcheck="true"># sending a request and getting an acknowledgement</span>syncLimit<span class="token operator">=</span>5<span class="token comment" spellcheck="true"># the directory where the snapshot is stored.</span><span class="token comment" spellcheck="true"># do not use /tmp for storage, /tmp here is just </span><span class="token comment" spellcheck="true"># example sakes.</span>dataDir<span class="token operator">=</span>/usr/local/zookeeper-3.5.6/zkDataDir<span class="token comment" spellcheck="true"># the port at which the clients will connect</span>clientPort<span class="token operator">=</span>2181<span class="token comment" spellcheck="true"># the maximum number of client connections.</span><span class="token comment" spellcheck="true"># increase this if you need to handle more clients</span><span class="token comment" spellcheck="true">#maxClientCnxns=60</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># Be sure to read the maintenance section of the </span><span class="token comment" spellcheck="true"># administrator guide before turning on autopurge.</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><span class="token comment" spellcheck="true">#</span><span class="token comment" spellcheck="true"># The number of snapshots to retain in dataDir</span><span class="token comment" spellcheck="true">#autopurge.snapRetainCount=3</span><span class="token comment" spellcheck="true"># Purge task interval in hours</span><span class="token comment" spellcheck="true"># Set to "0" to disable auto purge feature</span><span class="token comment" spellcheck="true">#autopurge.purgeInterval=1</span>server.1<span class="token operator">=</span>192.168.6.103:2888:3888server.2<span class="token operator">=</span>192.168.6.104:2888:3888server.3<span class="token operator">=</span>192.168.6.105:2888:3888</code></pre></li><li><p>主要有是修改了数据目录dataDir和最后三行的集群配置，其他用默认就好了</p></li><li><p>最后三行的集群配置解析<br><code>server.1=192.168.6.103:2888:3888</code><br>server.1中的数字1表示这个是第几号服务器；<br>192.168.6.103是这个服务器的ip地址；<br>2888是这个服务器与集群中的Leader服务器交换信息的端口(集群通讯端口)；<br>3888是集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口（选举端口）。</p></li><li><p>在zkDataDir目录中新建一个myid文件（三个服务器都需要此文件），文件内容就是对应服务器的编号，<br>在配置文件中的最后三行配置的server.1是指定192.168.6.103服务器的，所以要在myid文件中写入编号<code>1</code>，在192.168.6.104服务器上myid文件中写入编号<code>2</code>，105服务器上写入<code>3</code></p></li></ol><p><strong><font color="red">防坑</font></strong>：以上步骤除了第6步骤外，集群的其他配置都一样；</p><h3 id="五、集群操作"><a href="#五、集群操作" class="headerlink" title="五、集群操作"></a>五、集群操作</h3><ol><li><p>启动zk：<code>bin/zkServer.sh start</code></p></li><li><p>停止zk：<code>bin/zkServer.sh stop</code></p></li><li><p>重启zk：<code>bin/zkServer.sh restart</code></p></li><li><p>查看状态：<code>bin/zkServer.sh status</code></p></li><li><p>这里我编写了一个shell脚本，可以方便的管理zk集群：<br><strong><font color="green">说明一下</font></strong>：这个脚本可以在master、slave1-5的任意一台机器上运行，但前提是运行该脚本的机器需能够免密登陆到slave3、4、5上</p><pre class=" language-bash"><code class="language-bash"><span class="token shebang important">#!/bin/bash</span><span class="token keyword">echo</span> <span class="token string">'你执行的命令是：'</span><span class="token variable">$1</span><span class="token keyword">for</span> host <span class="token keyword">in</span> slave3 slave4 slave5<span class="token keyword">do</span><span class="token keyword">echo</span> <span class="token string">'开始在'</span><span class="token variable">$host</span>‘上的执行命令’<span class="token function">ssh</span> <span class="token variable">$host</span> <span class="token string">"source /etc/profile;/usr/local/zookeeper-3.5.6/bin/zkServer.sh <span class="token variable">$1</span>"</span><span class="token keyword">echo</span> <span class="token string">'执行完毕！退出'</span><span class="token variable">$host</span><span class="token keyword">done</span></code></pre><p>脚本运行效果：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191128/5.1.png" align="left/"></li></ol><h3 id="六、zk常用命令"><a href="#六、zk常用命令" class="headerlink" title="六、zk常用命令"></a>六、zk常用命令</h3><table><thead><tr><th align="center">序号</th><th align="center">命令</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">create /a ‘我是数据’</td><td align="center">创建默认永久节点(注意父节点必须要存在)</td></tr><tr><td align="center">2</td><td align="center">create -e /b ‘我是数据’</td><td align="center">创建临时节点(注意父节点必须要存在)</td></tr><tr><td align="center">3</td><td align="center">create -s /a/c ‘我是数据’</td><td align="center">创建带顺序编号的永久节点(注意父节点必须要存在)</td></tr><tr><td align="center">4</td><td align="center">create -e -s /a/d ‘我是数据’</td><td align="center">创建临时节点带顺序编号(注意父节点必须要存在)</td></tr><tr><td align="center">5</td><td align="center">get /a</td><td align="center">获取znode的数据</td></tr><tr><td align="center">6</td><td align="center">set /a ‘我是数据’</td><td align="center">设置znode的数据</td></tr><tr><td align="center">7</td><td align="center">ls /a</td><td align="center">查看znode的树下的节点</td></tr><tr><td align="center">8</td><td align="center">delete /a</td><td align="center">只能删除没有子节点的znode</td></tr><tr><td align="center">9</td><td align="center">rmr /a</td><td align="center">不管里面有多少子节点znode，统统删除</td></tr><tr><td align="center">10</td><td align="center">stat /a</td><td align="center">查看节点信息</td></tr><tr><td align="center">11</td><td align="center">quit</td><td align="center">退出zookeeper</td></tr><tr><td align="center">12</td><td align="center">connect 192.168.6.105:2181</td><td align="center">连接集群中的别的节点</td></tr><tr><td align="center">13</td><td align="center">ls2 /a</td><td align="center">查看当前节点的子节点及当前节点的信息</td></tr><tr><td align="center">14</td><td align="center">get /a  watch</td><td align="center">a节点的数据变化事件注册了监听</td></tr><tr><td align="center">15</td><td align="center">ls /a watch</td><td align="center">对a节点的子节点变化事件注册了监听</td></tr></tbody></table><p>附：zk节点数据结构</p><table><thead><tr><th align="center">节点名称</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">czxid</td><td align="center">节点创建时的事务id</td></tr><tr><td align="center">mzxid</td><td align="center">节点修改时的事务id</td></tr><tr><td align="center">pzxid</td><td align="center">最近一次修改子节点的事务id</td></tr><tr><td align="center">ctime</td><td align="center">节点创建时间</td></tr><tr><td align="center">mtime</td><td align="center">节点修改时间</td></tr><tr><td align="center">dataversion</td><td align="center">数据版本，每修改一次加1</td></tr><tr><td align="center">cversion</td><td align="center">子节点版本号，每修改一次子节点，加1</td></tr><tr><td align="center">aversion</td><td align="center">ACL版本号</td></tr><tr><td align="center">ephemeralOwner</td><td align="center">是否是临时节点，0代表永久节点</td></tr><tr><td align="center">dataLength</td><td align="center">数据长度</td></tr><tr><td align="center">numChildren</td><td align="center">子节点个数</td></tr></tbody></table><h3 id="七、zk选举机制"><a href="#七、zk选举机制" class="headerlink" title="七、zk选举机制"></a>七、zk选举机制</h3><p>zk的选举机制蛮有意思的，先上一张网络配图（流程图）：<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191128/7.1.jpg" align="left/"></p><p><a href="https://blog.csdn.net/wyqwilliam/article/details/83537139" title="zookeeper的选举机制" target="_blank" rel="noopener"><strong>zookeeper的选举机制</strong></a>,这篇博文写的非常详细，值得一看。</p><p>选举出现的情况分为2种：</p><ol><li>服务器初始化启动。<br>无论是哪种情况，都将优先对比ZXID（事务ID），其次是SID（myid里面配置的serverId）<br>由于第一此启动的时候ZXID都是0 ，所以会对比myid，也就是说SID大的，被选举的几率就大，<br>例如：<br>在slave3、slave4、slave5上面部署zk集群，myid配置文件中分别是1,2,3，假设zk集群的启动顺序是slave4-slave3-slave5：<br>1). slave4启动后，把票投给自己，广播后发现集群中只有自己一个，集群中有三台zk（配置文件中配置了三台），票数没有过半，zk就会处于等待状态（LOOKING）；<br>2). slave3启动，投自己一票，广播后发现有个兄弟在线，接收到他的投票，首先会对比ZXID都是0，在对比myid，发现slave4的myid比自己大，slave3就会更新自己的投票，把票投给slave4；而对于slave4而言，无须更新自己的投票，只是再次向集群中所有机器广播上一次投票信息即可；<br>3). 投票统计slave4票数过半，slave4变成leader（LEADING），slave3变成小弟（FOLLOWING）；<br>4). slave5启动后发现集群中已经存到leader，自动变成小弟。</li></ol><ol start="2"><li>服务器运行期间无法和Leader保持连接。<br>1). 服务器运行期间，leader挂掉之后，集群中的FOLLOWING都会变成（LOOKING）状态，并进入选举过程；<br>2). 每个zk都会为自己投一票，运行期间每个zk上的ZXID是有可能不同的，选举线程会将收到的票数进行统计比较，还有优先比较ZXID，这时候ZXID大的zk成为leader的几率就大</li></ol><p>选举算法和选举具体细节上面那篇博文已经很清楚了，推荐阅读！</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> zookeeper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用免费的CDN加速你的网站</title>
      <link href="/2019/11/25/%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84CDN%E5%8A%A0%E9%80%9F%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2019/11/25/%E4%BD%BF%E7%94%A8%E5%85%8D%E8%B4%B9%E7%9A%84CDN%E5%8A%A0%E9%80%9F%E4%BD%A0%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>拥有一个域名；</li><li>在cloudflare上注册账号，创建一个site；</li><li>在域名注册商那里修改cloudflare所提供的nds地址；</li><li>在cloudflare上添加一个要加速的网站地址，可以是ip或者域名网站（这个属于记录类型的不同，后面会讲到）；</li><li>测试配置成功与否；</li><li>个人理解的域名的记录类型；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>域名一个（二级域名也可以）；</li><li>cloudflare账号一个（直接注册）；</li></ol><h3 id="三、拥有一个域名"><a href="#三、拥有一个域名" class="headerlink" title="三、拥有一个域名"></a>三、拥有一个域名</h3><p>现在去阿里云、腾讯云买域名非常便宜，而且备案也方便了，不需要邮寄纸质备案申请表了，直接在网上审批即可，购买一个域名到成功备案半个月便能办好。<br>阿里云备案流程可以看这里：<a href="https://help.aliyun.com/knowledge_detail/36922.html" title="阿里云备案" target="_blank" rel="noopener">阿里云备案</a></p><h3 id="四、在cloudflare上注册账号，创建一个site"><a href="#四、在cloudflare上注册账号，创建一个site" class="headerlink" title="四、在cloudflare上注册账号，创建一个site"></a>四、在cloudflare上注册账号，创建一个site</h3><p>cloudflare官网：<a href="https://dash.cloudflare.com/login" title="cloudflare" target="_blank" rel="noopener">cloudflare</a></p><p>注册登陆之后在首页右上角有个‘add site’的按钮，添加你的顶级域名，<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/4.1.png" align="left/"></p><h3 id="五、域名的dns修改成cloudflare所提供的nds地址"><a href="#五、域名的dns修改成cloudflare所提供的nds地址" class="headerlink" title="五、域名的dns修改成cloudflare所提供的nds地址"></a>五、域名的dns修改成cloudflare所提供的nds地址</h3><p>进入域名页面后再进入DNS标签页中，找到cloudflare提供给你的两个DNS服务地址，并记录下来<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/5.1.png" align="left/"><br>去域名注册商那里修改顶级域名或二级域名的DNS地址为cloudflare提供DNS服务地址（如上图）<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/5.2.png" align="left/"><br><strong><font color="red">注意点</font></strong>：我的域名是阿里云域名（一般在域名注册商那里都能修改dns，好好找找就能找到），我配置的也是二级域名的dns解析，如果要是直接修改的顶级域名的dns，那么该顶级域名下的所有二级域名dns解析都会变成你修改的，因为我只加速了这一个二级域名下的网站，所以只改这个域名的dns。</p><p>检查域名的dns配置：<a href="https://zijian.aliyun.com" title="域名检查工具" target="_blank" rel="noopener">域名检查工具</a><br>附图：<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/5.3.png" align="left/"></p><h3 id="六、在cloudflare上添加一个要加速的网站地址"><a href="#六、在cloudflare上添加一个要加速的网站地址" class="headerlink" title="六、在cloudflare上添加一个要加速的网站地址"></a>六、在cloudflare上添加一个要加速的网站地址</h3><p>上述步骤配置完成后，再回到cloudflare的dns标签页下，添加一个你需要加速的网站<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/6.1.png" align="left/"></p><h3 id="七、测试配置"><a href="#七、测试配置" class="headerlink" title="七、测试配置"></a>七、测试配置</h3><p>配置完成后，一般需要等待几分钟到十几分钟后便可以测试有没有加速成功，<br>例如我上述配置中<code>lhy.erdongchen.top</code>此域名指向的是一台ip为：<code>93.179.112.20</code>的服务器，我在阿里云上修改这个域名的dns后，在cloudflare上配置好后，用自己笔记本打开cmd的ping命令得出的ip不是我服务器的IP地址（93.179.112.20），而是另一个ip，说明已经配置成功了！<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20191125/7.1.png" align="left/"><br><strong><font color="green">说明</font></strong>此种配置方式可以屏蔽掉真实的ip地址，可以提升服务器的安全等级；</p><h3 id="八、域名常用的记录类型说明"><a href="#八、域名常用的记录类型说明" class="headerlink" title="八、域名常用的记录类型说明"></a>八、域名常用的记录类型说明</h3><table><thead><tr><th align="center">记录类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">A记录</td><td align="center">A记录是用来指定域名或子域名对应的IP地址记录，保证域名指向对应的主机。将该域名下的网站服务器指向到自己的服务器上。该记录只能填写IP地址</td></tr><tr><td align="center">CNAME</td><td align="center">CNAME即我们常说的别名记录，该记录允许你为自己的主机设置别名。我们要多个域名指向同一个网站的时候，用CNAME就比较方便。</td></tr><tr><td align="center">NS记录</td><td align="center">NS即Name Server，该记录主要是用于指定域名是由那个DNS服务器来进行域名解析</td></tr><tr><td align="center">MX记录</td><td align="center">即邮件路由记录，用户可以将该域名下的邮件服务器指向到自己的mail server上，然后即可自行操控所有的邮箱设置</td></tr><tr><td align="center">TXT记录</td><td align="center">TXT记录是域名系统 (DNS) 中由域名托管服务商存储的一种资源记录。</td></tr><tr><td align="center">AAAA记录</td><td align="center">AAAA记录是用来指定网站域名对应的IPv6地址记录。</td></tr><tr><td align="center">TTL值</td><td align="center">TTL=time to live，表示解析记录在DNS服务器中的缓存时间。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CDN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名 </tag>
            
            <tag> 加速 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(二)-HDFS集群安装配置并附常用命令</title>
      <link href="/2019/11/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%BA%8C)-HDFS%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%B9%B6%E9%99%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/08/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%BA%8C)-HDFS%E9%9B%86%E7%BE%A4%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%B9%B6%E9%99%84%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>hadoop集群部署服务器规划；</li><li>hadoop安装包的下载解压；</li><li>配置hadoop的系统环境变量；</li><li>修改配置文件（主要四个文件：core-site.xml,hdfs-site.xml,hadoop-env.sh,worker）；</li><li>初始化namenode节点；</li><li>启动hdfs；</li><li>HDFS的其他配置项；</li><li>HDFS常用命令总结；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>承上启下，沿用第一篇大数据教程中的环境及软件；</li><li>hadoop安装包版本为：hadoop-3.2.1</li></ol><h3 id="三、hadoop集群部署服务器规划"><a href="#三、hadoop集群部署服务器规划" class="headerlink" title="三、hadoop集群部署服务器规划"></a>三、hadoop集群部署服务器规划</h3><p>计划在master（192.168.1.100）、slave（192.168.1.101）、slave2（192.168.1.102）上安装部署hadoop；<br>master节点上部署namenode<br>slave1、slave2节点上部署datanode<br>slave1上部署SecondaryNameNode节点</p><h3 id="四、hadoop安装包的下载解压"><a href="#四、hadoop安装包的下载解压" class="headerlink" title="四、hadoop安装包的下载解压"></a>四、hadoop安装包的下载解压</h3><p>hadoop官方网站：<a href="https://hadoop.apache.org" title="hadoop" target="_blank" rel="noopener"><strong>访问hadoop</strong></a><br>命令下载：<code>wget http://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.2.1/hadoop-3.2.1.tar.gz</code><br>解压命令：<code>tar -xzvf hadoop-3.2.1.tar.gz -C /usr/local/</code></p><h3 id="五、配置hadoop的系统环境变量"><a href="#五、配置hadoop的系统环境变量" class="headerlink" title="五、配置hadoop的系统环境变量"></a>五、配置hadoop的系统环境变量</h3><p>修改文件 /etc/profile （<font color="red">三台机器都要修改</font>）</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 1.编辑文件</span>vim /etc/profile<span class="token comment" spellcheck="true"># 2.文件底部增加以下内容：</span><span class="token comment" spellcheck="true"># hadoop</span>HADOOP_HOME<span class="token operator">=</span>/usr/local/hadoop-3.2.1PATH<span class="token operator">=</span><span class="token variable">$HADOOP_HOME</span>/bin:<span class="token variable">$PATH</span><span class="token function">export</span> HADOOP_HOME PATH<span class="token comment" spellcheck="true"># 3.刷新</span><span class="token function">source</span> /etc/profile</code></pre><h3 id="六、修改配置文件"><a href="#六、修改配置文件" class="headerlink" title="六、修改配置文件"></a>六、修改配置文件</h3><ol><li>修改配置文件：/usr/local/hadoop-3.2.1/etc/hadoop/core-site.xml （<font color="red">三台机器都要修改</font>）<pre class=" language-xml"><code class="language-xml"> # 新增以下内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>fs.defaultFS<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>hdfs://master:10001<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>HDFS的URI，文件系统://namenode标识:端口<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>hadoop.tmp.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/usr/local/hadoop-3.2.1/tmp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>namenode上传到hadoop的临时文件夹<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>fs.checkpoint.period<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>3600<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>用来设置检查点备份日志的最长时间<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre></li><li>修改配置文件：/usr/local/hadoop-3.2.1/etc/hadoop/hdfs-site.xml （<font color="red">三台机器都要修改</font>）<pre class=" language-xml"><code class="language-xml"> # 新增以下内容 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.replication<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>副本个数，默认配置是3，应小于datanode机器数量<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.name.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/usr/local/hadoop-3.2.1/namenode<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>namenode上存储hdfs名字空间元数据<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.data.dir<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>/usr/local/hadoop-3.2.1/datanode<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>description</span><span class="token punctuation">></span></span>datanode上数据块的物理存储位置<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>description</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre></li><li>修改配置文件：/usr/local/hadoop-3.2.1/etc/hadoop/hadoop-env.sh （<font color="red">三台机器都要修改</font>）<pre class=" language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 在文件末尾新增一行</span> <span class="token function">export</span> JAVA_HOME<span class="token operator">=</span>/usr/local/jdk1.8.0_161</code></pre></li><li>在master机器上修改文件（namenode节点）：/usr/local/hadoop-3.2.1/etc/hadoop/worker<pre class=" language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 新增以下内容</span> master slave1 slave2</code></pre></li></ol><h3 id="七、初始化namenode节点"><a href="#七、初始化namenode节点" class="headerlink" title="七、初始化namenode节点"></a>七、初始化namenode节点</h3><p> 初始化命令：<code>hadoop namenode -format</code></p><h3 id="八、启动hdfs"><a href="#八、启动hdfs" class="headerlink" title="八、启动hdfs"></a>八、启动hdfs</h3><p>启动HDFS集群命令<code>/usr/local/hadoop-3.2.1/sbin/start-dfs.sh</code><br><strong><font color="red">防坑</font></strong>：启动报错：</p><pre><code>    Starting namenodes on [master]    ERROR: Attempting to operate on hdfs namenode as root    ERROR: but there is no HDFS_NAMENODE_USER defined. Aborting operation.    Starting datanodes    ERROR: Attempting to operate on hdfs datanode as root    ERROR: but there is no HDFS_DATANODE_USER defined. Aborting operation.    Starting secondary namenodes [master]    ERROR: Attempting to operate on hdfs secondarynamenode as root    ERROR: but there is no HDFS_SECONDARYNAMENODE_USER defined. Aborting operation.</code></pre><p><strong><font color="green">解决方案</font></strong>：</p><ol><li>修改配置文件：start-dfs.sh、stop-dfs.sh （<font color="red">三台机器都要修改</font>）<pre class=" language-bash"><code class="language-bash"> vim /usr/local/hadoop-3.2.1/sbin/start-dfs.sh vim /usr/local/hadoop-3.2.1/sbin/stop-dfs.sh <span class="token comment" spellcheck="true">#在两个文件的顶部位置添加如下内容</span> HDFS_DATANODE_USER<span class="token operator">=</span>root HADOOP_SECURE_DN_USER<span class="token operator">=</span>hdfs HDFS_NAMENODE_USER<span class="token operator">=</span>root HDFS_SECONDARYNAMENODE_USER<span class="token operator">=</span>root</code></pre></li><li>修改配置文件：start-yarn.sh、stop-yarn.sh （<font color="red">三台机器都要修改</font>）<pre class=" language-bash"><code class="language-bash"> vim /usr/local/hadoop-3.2.1/sbin/start-yarn.sh vim /usr/local/hadoop-3.2.1/sbin/stop-yarn.sh <span class="token comment" spellcheck="true">#在两个文件的顶部位置添加如下内容</span> YARN_RESOURCEMANAGER_USER<span class="token operator">=</span>root HADOOP_SECURE_DN_USER<span class="token operator">=</span>yarn YARN_NODEMANAGER_USER<span class="token operator">=</span>root</code></pre><font color="green">备注：如果用其他账号启动HDFS，则所有root字符串位置替换成你的登陆用户名</font><br>启动完成后，可以访问web页面：<a href="http://192.168.6.100:9870" target="_blank" rel="noopener">http://192.168.6.100:9870</a></li></ol><h3 id="九、HDFS的其他配置项"><a href="#九、HDFS的其他配置项" class="headerlink" title="九、HDFS的其他配置项"></a>九、HDFS的其他配置项</h3><ol><li>默认配置时，SecondaryNameNode节点是会在namenode节点上启动的，如需指定的别的节点上启动，可在hdfs-site.xml中增加以下配置<pre class=" language-xml"><code class="language-xml"> <span class="token comment" spellcheck="true">&lt;!-- 配置secondaryNameNode --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>property</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>name</span><span class="token punctuation">></span></span>dfs.namenode.secondary.http-address<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>name</span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>value</span><span class="token punctuation">></span></span>slave1:50090<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>value</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>property</span><span class="token punctuation">></span></span></code></pre></li></ol><h3 id="十、HDFS常用命令总结"><a href="#十、HDFS常用命令总结" class="headerlink" title="十、HDFS常用命令总结"></a>十、HDFS常用命令总结</h3><table><thead><tr><th align="center">序号</th><th align="center">参数格式</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">hadoop fs -ls</td><td align="center">显示当前目录结构，-ls -R 递归显示目录结构</td></tr><tr><td align="center">2</td><td align="center">hadoop fs -mkdir</td><td align="center">创建目录</td></tr><tr><td align="center">3</td><td align="center">hadoop fs -rm</td><td align="center">删除文件，-rm -R 递归删除目录和文件</td></tr><tr><td align="center">4</td><td align="center">hadoop fs -put [localsrc] [dst]</td><td align="center">从本地加载文件到HDFS</td></tr><tr><td align="center">5</td><td align="center">hadoop fs -get [dst] [localsrc]</td><td align="center">从HDFS导出文件到本地</td></tr><tr><td align="center">6</td><td align="center">hadoop fs - copyFromLocal [localsrc] [dst]</td><td align="center">从本地加载文件到HDFS，与put一致</td></tr><tr><td align="center">7</td><td align="center">hadoop fs -copyToLocal [dst] [localsrc]</td><td align="center">从HDFS导出文件到本地，与get一致</td></tr><tr><td align="center">8</td><td align="center">hadoop fs -test -e</td><td align="center">检测目录和文件是否存在，存在返回值$?为0，不存在返回1</td></tr><tr><td align="center">9</td><td align="center">hadoop fs -text</td><td align="center">查看文件内容</td></tr><tr><td align="center">10</td><td align="center">hadoop fs -du</td><td align="center">统计目录下各文件大小，单位字节。-du -s 汇总目录下文件大小，-du -h 显示单位</td></tr><tr><td align="center">11</td><td align="center">hadoop fs -tail</td><td align="center">显示文件末尾</td></tr><tr><td align="center">12</td><td align="center">hadoop fs -cp [src] [dst]</td><td align="center">从源目录复制文件到目标目录</td></tr><tr><td align="center">13</td><td align="center">hadoop fs -mv [src] [dst]</td><td align="center">从源目录移动文件到目标目录</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初探-搭建 ELK+Filebeat 分布式日志采集分析平台</title>
      <link href="/2019/10/25/%E5%88%9D%E6%8E%A2-%E6%90%AD%E5%BB%BA-ELK-Filebeat-%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/"/>
      <url>/2019/10/25/%E5%88%9D%E6%8E%A2-%E6%90%AD%E5%BB%BA-ELK-Filebeat-%E5%88%86%E5%B8%83%E5%BC%8F%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86%E5%88%86%E6%9E%90%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="本篇教程侧重点导读"><a href="#本篇教程侧重点导读" class="headerlink" title="* 本篇教程侧重点导读"></a>* 本篇教程侧重点导读</h3><ol><li>教程涉及到的软件，技术，</li><li>ELK日志采集分析平台的技术框架介绍；</li><li>elasticsearch的安装部署单机、集群环境；</li><li>kibana的安装部署；</li><li>logtash的安装部署；</li><li>Filebeat日志采集的安装部署；</li><li>打通链路，日志采集-&gt;日志过滤分析-&gt;日志存储搜索-&gt;日志分析展示；</li><li>数据库数据的采集；</li><li>elasticsearch-head插件安装；</li></ol><h3 id="一、教程涉及到的软件，技术"><a href="#一、教程涉及到的软件，技术" class="headerlink" title="一、教程涉及到的软件，技术"></a>一、教程涉及到的软件，技术</h3><ol><li>使用到linux系统：CentOS 7；</li><li>安装ELK的前提是服务器需要java环境，我用的是：1.8.0_112;</li><li>elasticsearch、kibana、logtash和Filebeat都要使用同一版本（我使用的是7.4.0）；</li><li>ELK官方地址；<a href="https://www.elastic.co" title="go" target="_blank" rel="noopener">www.elastic.co</a></li><li>本篇使用了三台服务器，IP地址分别为192.168.1.220、192.168.1.221、192.168.1.222，并且在每台服务器上创建了一个账号和组（elk）；</li><li>此篇教程是分享个人理解的ELK技术框架，以及搭建过程，如有错误，敬请指出！</li></ol><h3 id="二、ELK日志采集分析平台的技术框架介绍"><a href="#二、ELK日志采集分析平台的技术框架介绍" class="headerlink" title="二、ELK日志采集分析平台的技术框架介绍"></a>二、ELK日志采集分析平台的技术框架介绍</h3><p>话不多说，先上一张网络图！<br><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/elk架构图.png" align="left/"></p><h3 id="三、elasticsearch的安装部署集群环境"><a href="#三、elasticsearch的安装部署集群环境" class="headerlink" title="三、elasticsearch的安装部署集群环境"></a>三、elasticsearch的安装部署集群环境</h3><ol><li><p>在三台服务器上都丢一个es(elasticsearch)安装包，并解压；</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/3.1.png" align="left/"></li><li><p>在三台服务器上都创建一个账号并把elasticsearch-7.4.0文件夹的所属用户所属组改一下（elk官方不建议使用root运行ELK）</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建组</span><span class="token function">groupadd</span> elk<span class="token comment" spellcheck="true"># 创建用户</span><span class="token function">useradd</span> elk -g elk -p 123456<span class="token comment" spellcheck="true"># 修改文件夹权限</span>chonw -R elk:elk elasticsearch-7.4.0</code></pre></li><li><p>我把192.168.1.220作为es主节点，221和222作为数据节点，集群环境配置如下：<br>在服务器220上的es解压目录进入config目录，编辑elasticsearch.yml文件，新增如下内容：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 集群中的名称</span>cluster.name: es-master-node<span class="token comment" spellcheck="true"># 该节点名称</span>node.name: master<span class="token comment" spellcheck="true"># 该节点设置为主节点</span>node.master: <span class="token boolean">true</span><span class="token comment" spellcheck="true"># 该节点不是数据节点</span>node.data: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># 监听全部ip，在实际环境中应设置为一个安全的ip</span>network.host: 0.0.0.0<span class="token comment" spellcheck="true"># es服务端口号</span>http.port: 9200<span class="token comment" spellcheck="true"># 配置自动发现</span>discovery.seed_hosts: <span class="token punctuation">[</span><span class="token string">"192.168.1.220"</span>,<span class="token string">"192.168.1.221"</span>, <span class="token string">"192.168.1.222"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 跨域配置</span>http.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span><span class="token comment" spellcheck="true"># 初始化主节点</span>cluster.initial_master_nodes: 192.168.1.220</code></pre></li><li><p>服务器221和222上的elasticsearch.yml文件配置为：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 集群中的名称</span>cluster.name: es-master-node<span class="token comment" spellcheck="true"># 该节点名称(node.name 可以自己起名字  只要三台服务器的节点明恒不一样就行)</span>node.name: <span class="token comment" spellcheck="true"># 该节点从节点</span>node.master: <span class="token boolean">false</span><span class="token comment" spellcheck="true"># 该节点是数据节点</span>node.data: <span class="token boolean">true</span><span class="token comment" spellcheck="true"># 监听全部ip，在实际环境中应设置为一个安全的ip</span>network.host: 0.0.0.0<span class="token comment" spellcheck="true"># es服务端口号</span>http.port: 9200<span class="token comment" spellcheck="true"># 配置自动发现</span>discovery.seed_hosts: <span class="token punctuation">[</span><span class="token string">"192.168.1.220"</span>,<span class="token string">"192.168.1.221"</span>, <span class="token string">"192.168.1.222"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 跨域配置</span>http.cors.enabled: <span class="token boolean">true</span>http.cors.allow-origin: <span class="token string">"*"</span></code></pre></li><li><p>在es主节点服务器上启动es：</p><pre class=" language-bash"><code class="language-bash">./bin/elasticsearch <span class="token operator">&amp;</span></code></pre><p><strong><font color="red">启动报错</font></strong>：<br><font color="red">ERROR: [1] bootstrap checks failed<br>[1]: max file descriptors [4096] for elasticsearch process is too low, increase to at least [65535]</font><br><strong><font color="green">解决方案</font></strong>：<br><font color="green">切换都root用户下执行</font></p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 查看硬限制</span><span class="token function">ulimit</span> -Hn<span class="token comment" spellcheck="true"># 编辑文件</span>vim /etc/security/limits.conf<span class="token comment" spellcheck="true"># 添加如下配置(elk为启动es的用户名)</span>elk soft nofile 65536elk hard nofile 65536</code></pre><p><font color="green">需退出用户后重新登录，再次查看elk用户的硬限制，如果变为65536，说明设置成功！</font></p></li><li><p>主节点启动成功后，在启动两个从节点，其中9200是数据传输时端口，9300是集群通信端口</p></li><li><p>验证：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># es集群健康检查</span>curl <span class="token string">'192.168.1.220:9200/_cluster/health?pretty'</span><span class="token comment" spellcheck="true"># 返回的内容</span><span class="token punctuation">{</span><span class="token string">"cluster_name"</span> <span class="token keyword">:</span> <span class="token string">"es-master-node"</span>,<span class="token string">"status"</span> <span class="token keyword">:</span> <span class="token string">"green"</span>, <span class="token comment" spellcheck="true"># 为green则代表健康没问题，如果是yellow或者red则是集群有问题</span><span class="token string">"timed_out"</span> <span class="token keyword">:</span> false, <span class="token comment" spellcheck="true"># 是否有超时</span><span class="token string">"number_of_nodes"</span> <span class="token keyword">:</span> 3, <span class="token comment" spellcheck="true"># 集群中的节点数量</span><span class="token string">"number_of_data_nodes"</span> <span class="token keyword">:</span> 2, <span class="token comment" spellcheck="true"># 集群中data节点的数量</span><span class="token string">"active_primary_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"active_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"relocating_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"initializing_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"unassigned_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"delayed_unassigned_shards"</span> <span class="token keyword">:</span> 0,<span class="token string">"number_of_pending_tasks"</span> <span class="token keyword">:</span> 0,<span class="token string">"number_of_in_flight_fetch"</span> <span class="token keyword">:</span> 0,<span class="token string">"task_max_waiting_in_queue_millis"</span> <span class="token keyword">:</span> 0,<span class="token string">"active_shards_percent_as_number"</span> <span class="token keyword">:</span> 100.0<span class="token punctuation">}</span><span class="token comment" spellcheck="true"># 查看集群详细信息</span>curl <span class="token string">'192.168.1.220:9200/_cluster/state?pretty'</span></code></pre></li></ol><h3 id="四、kibana的安装部署（我是部署在220上-部署服务器随意选择，只要配置对就好）"><a href="#四、kibana的安装部署（我是部署在220上-部署服务器随意选择，只要配置对就好）" class="headerlink" title="四、kibana的安装部署（我是部署在220上,部署服务器随意选择，只要配置对就好）"></a>四、kibana的安装部署（我是部署在220上,部署服务器随意选择，只要配置对就好）</h3><ol><li>将安装包解压至/usr/local/elk目录下，并修改权限到elk用户上</li><li>修改kibana解压目录下config里面的配置文件：kibana.yml，新增如下内容：<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 配置kibana的端口</span>server.port: 5601<span class="token comment" spellcheck="true"># 配置监听ip</span>server.host: 192.168.1.220<span class="token comment" spellcheck="true"># 配置es服务器的ip，如果是集群则配置该集群中主节点的ip</span>elasticsearch.hosts: <span class="token punctuation">[</span><span class="token string">"http://192.168.1.220:9200"</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 配置kibana的日志文件路径，不然默认是messages里记录日志</span>logging.dest: /usr/local/elk/kibana-7.4.0-linux-x86_64/logs/kibana.logi18n.locale: <span class="token string">"zh-CN"</span></code></pre></li><li>浏览器访问；192.168.1.220:5601</li></ol><h3 id="五、logtash的安装部署（我是部署在221上，任意服务器上都可部署）"><a href="#五、logtash的安装部署（我是部署在221上，任意服务器上都可部署）" class="headerlink" title="五、logtash的安装部署（我是部署在221上，任意服务器上都可部署）"></a>五、logtash的安装部署（我是部署在221上，任意服务器上都可部署）</h3><ol><li><p>将安装包解压至/usr/local/elk目录下，并修改权限到elk用户上</p></li><li><p>在config目录下新建一个文件myLogstash.conf</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建文件myLogstash.conf</span><span class="token function">touch</span> myLogstash.conf<span class="token comment" spellcheck="true"># 增加如下内容</span>input <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">#定义日志源</span>beats <span class="token punctuation">{</span> port <span class="token operator">=</span><span class="token operator">></span> 9900 <span class="token comment" spellcheck="true">#监听端口</span><span class="token punctuation">}</span><span class="token punctuation">}</span>output <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">#日志输出源</span><span class="token keyword">if</span> <span class="token string">"nginxlog"</span> <span class="token keyword">in</span> <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">#这里的配置是接收Filebeat传过来的日志做分类处理，存到不同的es表里</span>elasticsearch <span class="token punctuation">{</span> <span class="token comment" spellcheck="true"># 输出到es</span> hosts <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"http://192.168.1.220:9200"</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># es主节点所在IP</span> index <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"nginx-%{+YYYY.MM.dd}"</span> <span class="token comment" spellcheck="true"># 定义索引</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token string">"tomcatlog"</span> <span class="token keyword">in</span> <span class="token punctuation">[</span>tags<span class="token punctuation">]</span><span class="token punctuation">{</span>elasticsearch <span class="token punctuation">{</span> hosts <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token string">"http://192.168.1.220:9200"</span><span class="token punctuation">]</span> index <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"tomcat-%{+YYYY.MM.dd}"</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>检测配置文件是否正确</p><pre class=" language-bash"><code class="language-bash">./bin/logstash --path.settings /config -f config/myLogstash.conf --config.test_and_exit<span class="token comment" spellcheck="true">#参数说明</span>--path.settings <span class="token comment" spellcheck="true"># 指定logstash的配置文件所在目录</span>-f <span class="token comment" spellcheck="true"># 指定需要被检测的配置文件</span>--config.test_and_exit <span class="token comment" spellcheck="true"># 检测完之后就退出，不启动logstash</span></code></pre></li><li><p>启动logstash</p><pre class=" language-bash"><code class="language-bash">./bin/logstash -f config/myLogstash.conf <span class="token operator">&amp;</span></code></pre></li></ol><h3 id="六、将Filebeat日志采集部署至待采集的机器上"><a href="#六、将Filebeat日志采集部署至待采集的机器上" class="headerlink" title="六、将Filebeat日志采集部署至待采集的机器上"></a>六、将Filebeat日志采集部署至待采集的机器上</h3><p>需求：需采集192.168.1.182上的nginx和tomcat日志,182服务器是windows server服务器，所以我下载的Filebeat是zip格式包</p><ol><li>将Filebeat程序放到182上，并解压</li><li>修改配置文件filebet.yml:<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/6.2.png" align="left/"></li><li>启动Filebeat<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Filebeat目录执行</span>filebet.exe -c filebeat.yml</code></pre></li></ol><h3 id="七、链路打通"><a href="#七、链路打通" class="headerlink" title="七、链路打通"></a>七、链路打通</h3><ol><li>随便访问一下nginx和tomcat，使其产生日志</li><li>浏览器访问kibana服务查看es中的索引：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/7.2.png" align="left/"></li><li>或者访问 curl 192.168.1.220:9200/_cat/indices?v 同样可以查看到有索引建立</li><li>如上第二步或者第三步，可以看到，在logstash配置文件中定义的两个索引成功获取到了，证明配置没问题，logstash与es通信正常</li><li>在浏览器界面打开kibana服务，配置es中的两个索引：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/7.5.png" align="left/"></li><li>在Discover界面查看采集的日志数据：<img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20191025/7.6.png" align="left/"></li></ol><h3 id="八、数据库数据的采集"><a href="#八、数据库数据的采集" class="headerlink" title="八、数据库数据的采集"></a>八、数据库数据的采集</h3><p>logstash同样也可以采集数据库中的数据到es，只需要改input数据源中的相关配置就ok了，这里不再叙述详细步骤</p><h3 id="九、elasticsearch-head插件安装"><a href="#九、elasticsearch-head插件安装" class="headerlink" title="九、elasticsearch-head插件安装"></a>九、elasticsearch-head插件安装</h3><p>参考链接：<a href="https://blog.csdn.net/qq924862077/article/details/79994565" title="go" target="_blank" rel="noopener">elasticsearch-head插件安装</a></p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 环境搭建 </tag>
            
            <tag> 技术 </tag>
            
            <tag> 日志分析平台 </tag>
            
            <tag> ELK </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux常用命令解析(持续更新)</title>
      <link href="/2019/09/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/"/>
      <url>/2019/09/30/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E8%A7%A3%E6%9E%90(%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0)/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本篇文章是基于博主学习过程中积累的命令整理，会在职业生涯中持续更新，差不多都是常用命令，方便查阅备忘之用。</p><h3 id="本篇教程常用命令分类如下"><a href="#本篇教程常用命令分类如下" class="headerlink" title="本篇教程常用命令分类如下"></a>本篇教程常用命令分类如下</h3><ol><li>系统信息；</li><li>系统性能；</li><li>文件和目录；</li><li>文件权限；</li><li>文件查找；</li><li>查看文件内容；</li><li>文件处理；</li><li>用户与权限；</li><li>磁盘管理；</li><li>压缩与解压；</li><li>其他常用命令。</li></ol><h3 id="一、系统信息"><a href="#一、系统信息" class="headerlink" title="一、系统信息"></a>一、系统信息</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">uname</td><td align="center">显示系统信息</td></tr><tr><td align="center">cat /proc/version</td><td align="center">查看linux版本信息</td></tr><tr><td align="center">hostnamectl</td><td align="center">查看系统内核、系统版本信息</td></tr><tr><td align="center">cal 2019</td><td align="center">显示2019年日历</td></tr><tr><td align="center">ifconfig</td><td align="center">查看网卡信息</td></tr><tr><td align="center">cat /proc/cpuinfo</td><td align="center">显示CPU的信息</td></tr><tr><td align="center">cat /proc/cpuinfo | grep &#39;physical id&#39;| sort | uniq | wc -l</td><td align="center">查看物理CPU个数</td></tr><tr><td align="center">cat /proc/cpuinfo|grep &#39;cpu cores&#39;|uniq</td><td align="center">查看每个物理CPU的核心数</td></tr><tr><td align="center">cat /proc/cpuinfo|grep &#39;processor&#39;|wc -l</td><td align="center">查看逻辑CPU个数（CPU线程数）</td></tr><tr><td align="center">ping</td><td align="center">测试连接情况</td></tr></tbody></table><h3 id="二、系统性能"><a href="#二、系统性能" class="headerlink" title="二、系统性能"></a>二、系统性能</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th><th align="center">示例</th><th align="center">示例说明</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">top</td><td align="center">实时的显示cpu、内存、进程等使用情况（类似于windows下的任务管理器）</td><td align="center">top -d 3 -p 8243 -u mysql</td><td align="center">-d为界面刷新间隔时间，默认为5秒，-p指定进程id，-u指定用户名</td><td align="center"><a href="http://nginx.org/en/download.html" title="点击查看" target="_blank" rel="noopener">top命令的交互以及top各输出参数含义</a></td></tr><tr><td align="center">free</td><td align="center">查看系统内存及虚拟内存使用情况</td><td align="center">free -h</td><td align="center">以人类可读的方式显示内存信息</td><td align="center"></td></tr><tr><td align="center">iostat</td><td align="center">查看系统磁盘io负载分析、cpu使用情况</td><td align="center">iostat 2 5</td><td align="center">每2秒显示一次统计情况，一共显示5次</td><td align="center"></td></tr><tr><td align="center">du</td><td align="center">计算文件大小</td><td align="center">du -h /usr/local/nginx/</td><td align="center">显示指定路径下的各个文件的大小并汇总</td><td align="center"></td></tr><tr><td align="center">df</td><td align="center">显示磁盘的空间使用情况</td><td align="center">df -h</td><td align="center">人类可读的方式显示磁盘空间信息</td><td align="center"></td></tr><tr><td align="center">systemctl</td><td align="center">查看正在运行的服务</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h3 id="三、文件和目录"><a href="#三、文件和目录" class="headerlink" title="三、文件和目录"></a>三、文件和目录</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">cd</td><td align="center">进入当前登录用的的家目录（Change Directory的缩写）</td></tr><tr><td align="center">cd ..</td><td align="center">返回上一级目录</td></tr><tr><td align="center">cd -</td><td align="center">返回上次所在的目录</td></tr><tr><td align="center">cd /</td><td align="center">返回到根目录</td></tr><tr><td align="center">cd ./a/b</td><td align="center">进入当前a目录下的b目录（相对路径）</td></tr><tr><td align="center">cd /usr/local</td><td align="center">进入指定目录（绝对路径）</td></tr><tr><td align="center">pwd</td><td align="center">显示工作路径（Print Working Directory的缩写）</td></tr><tr><td align="center">ls -a</td><td align="center">列出目录下所有的文件（包括隐藏文件、文件夹）</td></tr><tr><td align="center">file 文件或目录</td><td align="center">显示文件类型</td></tr><tr><td align="center">mkdir abc</td><td align="center">在当前目录下创建目录abc，mkdir是make directory的缩写</td></tr><tr><td align="center">mkdir -p /a/b/c</td><td align="center">递归创建目录，-p表示父目录不存在时，先创建父目录</td></tr><tr><td align="center">touch abc.txt</td><td align="center">创建文件abc.txt</td></tr><tr><td align="center">rm 文件</td><td align="center">删除文件</td></tr><tr><td align="center">rm -r 文件或目录</td><td align="center">删除目录及目录下所有的文件</td></tr><tr><td align="center">rm -rf 文件或目录</td><td align="center">强制删除！不询问</td></tr><tr><td align="center">mv /usr/local/a /var/b</td><td align="center">移动a到var目录下并且改名为b</td></tr><tr><td align="center">cp -ai /usr/local/abc /var/</td><td align="center">复制abc目录或者文件到var目录下（-a表示文件的属性也复制，目录下所有文件都复制，-i表示覆盖前询问）</td></tr><tr><td align="center">scp -r /usr/local/abc.txt root@192.168.0.121:/root/</td><td align="center">远程传输文件：将本机的abc.txt传输到121服务器下的root目录下</td></tr><tr><td align="center">ln -s /usr/local/abc.txt /usr/local/</td><td align="center">创建文件的软连接，快捷方式名字不变</td></tr><tr><td align="center">ln -s /usr/local/abc.txt /usr/local/def.txt</td><td align="center">创建文件的软连接，快捷方式名字变为def.txt</td></tr><tr><td align="center">ln -s /usr/local /var/</td><td align="center">对目录创建软连接</td></tr><tr><td align="center">ln /usr/local/abc.txt /usr/local/</td><td align="center">创建文件的硬连接</td></tr></tbody></table><h3 id="四、文件权限"><a href="#四、文件权限" class="headerlink" title="四、文件权限"></a>四、文件权限</h3><ol><li><p><strong>命令</strong>：chmod<br><strong>命令含义</strong>：change mode的缩写，变更文件或目录的权限。<br><strong>语法1</strong>：<strong><font color="green">chmod [-cfvR] [{ugoa}{+-=}{rwx}] 文件或目录</font></strong><br><strong>语法2</strong>：<strong><font color="green">chmod [-cfvR] [421] 文件或目录</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">若该文件权限确实已经更改，才显示其更改动作</td></tr><tr><td align="center">-f</td><td align="center">若该文件权限法务被更改也不要显示错误讯息</td></tr><tr><td align="center">-v</td><td align="center">显示权限变更的详细信息</td></tr><tr><td align="center">-R</td><td align="center">对当前目录下的所有文件和子目录进行相同权限的变更</td></tr></tbody></table><p><strong>mode参数格式</strong>：[ugoa][+-=][rwxX][数字]</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">u</td><td align="center">表示该文件的拥有者</td></tr><tr><td align="center">g</td><td align="center">表示与该文件的拥有者属于同一个group中</td></tr><tr><td align="center">o</td><td align="center">表示其他以外的人</td></tr><tr><td align="center">a</td><td align="center">所有</td></tr><tr><td align="center">+</td><td align="center">增加权限</td></tr><tr><td align="center">-</td><td align="center">取消全校</td></tr><tr><td align="center">=</td><td align="center">唯一设定权限</td></tr><tr><td align="center">r</td><td align="center">可读取</td></tr><tr><td align="center">w</td><td align="center">可写入</td></tr><tr><td align="center">x</td><td align="center">可执行</td></tr><tr><td align="center">X</td><td align="center">只有当该文件是个子目录或者该文件以及被设定过为可执行</td></tr></tbody></table><p><strong>数字参数时权限含义</strong>：</p><table><thead><tr><th align="center">权限数值</th><th align="center">权限</th><th align="center">二进制</th><th align="center">具体作用</th></tr></thead><tbody><tr><td align="center">4</td><td align="center">r</td><td align="center">00000100</td><td align="center">read，读取。当前用户可以读取文件内容，当前用户可以浏览目录。</td></tr><tr><td align="center">2</td><td align="center">w</td><td align="center">00000010</td><td align="center">write，写入。当前用户可以新增或修改文件内容，当前用户可以删除、移动目录或目录内文件。</td></tr><tr><td align="center">1</td><td align="center">x</td><td align="center">00000001</td><td align="center">execute，执行。当前用户可以执行文件，当前用户可以进入目录。</td></tr></tbody></table><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">chmod u=rwx,g=rw,o=r test.txt</td><td align="center">给test.txt文件所有者设置<font color="red">读写执行</font>的权限，给所在组设置<font color="red">读写</font>权限，给其它组设置<font color="red">只读</font>权限</td></tr><tr><td align="center">chmod -v u-x,g+x test.txt</td><td align="center">为test.txt文件所有者去除<font color="red">执行</font>权限，为所在组增加<font color="red">执行</font>权限，并打印变更权限详细信息</td></tr><tr><td align="center">chmod +x test.txt</td><td align="center">为test.txt文件的所有者、所在组、其他组都增加<font color="red">执行</font>权限</td></tr><tr><td align="center">chmod 764 test.txt</td><td align="center">第一个数字7表示变更文件所有者权限为<font color="red">读写执行</font>，第二个数字6表示变更文件所在组权限为<font color="red">读写</font>，第三个数字4表示变更其他组权限为<font color="red">只读</font></td></tr><tr><td align="center">chmod 600 test.txt</td><td align="center">给test.txt文件所有者设置<font color="red">读写</font>的权限，其他所有人和组都无任何权限</td></tr></tbody></table></li><li><p><strong>命令</strong>：chown<br><strong>命令含义</strong>：change owner的缩写，更改所有者和所属组。<br><strong>语法</strong>：<strong><font color="green">chown [-cfvR] user[:group] 文件或目录</font></strong><br><strong>user</strong> : 表示新的文件拥有者的使用者 ID<br><strong>group</strong> : 表示新的文件拥有者的使用者组(group)</p><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">chown tom test.txt</td><td align="center">更改所属用户为tom</td></tr><tr><td align="center">chown :people test.txt</td><td align="center">更改所属组为people</td></tr><tr><td align="center">chown -R tom:people /usr/a目录</td><td align="center">更改a目录及子目录的所有者为tom、所属组为people</td></tr></tbody></table></li></ol><h3 id="五、文件查找"><a href="#五、文件查找" class="headerlink" title="五、文件查找"></a>五、文件查找</h3><ol><li><p><strong>命令</strong>：locate<br><strong>命令含义</strong>：在mlocate数据库中搜索条目.<br><strong>语法</strong>：<strong><font color="green">locate [OPTION]… [PATTERN]…</font></strong><br><strong>特点</strong>：<br>①.非实时，模糊匹配，查找是根据全系统文件数据库进行的；<br>②.如果文件数据库不存在，则不能查找；<br>③.updatedb，手动生成文件数据库；<br>④.基于索引查找，查找速度快；<br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-A, –all</td><td align="center">只显示匹配所有模式的条目</td></tr><tr><td align="center">-b, –basename</td><td align="center">只匹配路径名的基本名称</td></tr><tr><td align="center">-c, –count</td><td align="center">只显示找到的条目的数目</td></tr><tr><td align="center">-d, –database DBPATH</td><td align="center">使用 DBPATH，而非默认数据（即：/var/lib/mlocate/mlocate.db）</td></tr><tr><td align="center">-e, –existing</td><td align="center">只显示当前存在的文件条目</td></tr><tr><td align="center">-L, –follow</td><td align="center">当文件存在时跟随蔓延的符号链接（默认）</td></tr><tr><td align="center">-h, –help</td><td align="center">显示帮助信息</td></tr><tr><td align="center">-i, –ignore-case</td><td align="center">匹配模式时忽略大小写区别</td></tr><tr><td align="center">-l, –limit, -n LIMIT</td><td align="center">限制为 LIMIT项目的输出（或 计数）</td></tr><tr><td align="center">-m, –mmap</td><td align="center">被忽略，用于向后兼容</td></tr><tr><td align="center">-P, –nofollow, -H</td><td align="center">当检查文件时不跟随蔓延的符号链接</td></tr><tr><td align="center">-0, –null</td><td align="center">输出时以 NUL 分隔项目</td></tr><tr><td align="center">-S, –statistics</td><td align="center">不搜索项目,显示有关每个已用数据库的统计信息</td></tr><tr><td align="center">-q, –quiet</td><td align="center">不报告关于读取数据库的错误消息</td></tr><tr><td align="center">-r, –regexp REGEXP</td><td align="center">搜索基本正则表达式 REGEXP 而不是模式</td></tr><tr><td align="center">–regex</td><td align="center">模式是扩展正则表达式</td></tr><tr><td align="center">-s, –stdio</td><td align="center">被忽略，用于向后兼容</td></tr><tr><td align="center">-V, –version</td><td align="center">显示版本信息</td></tr><tr><td align="center">-w, –wholename</td><td align="center">匹配完整路径名（默认）</td></tr></tbody></table><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">locate /etc/sh</td><td align="center">搜索目录下所有以 sh 开头的文件</td></tr><tr><td align="center">locate passwd</td><td align="center">查找包含某个字符串的相关文件</td></tr><tr><td align="center">locate -n 5 passwd</td><td align="center">限定显示数量</td></tr><tr><td align="center">locate -i -n 5 passwd</td><td align="center">查找时不区分大小写</td></tr></tbody></table></li><li><p><strong>命令</strong>：find<br><strong>命令含义</strong>：功能强大的系统查找命令.<br><strong>语法</strong>：<strong><font color="green">find [-H] [-L] [-P] [-Olevel] [-D help|tree|search|stat|rates|opt|exec] [path…] [expression]</font></strong><br><strong>常用参数说明</strong>：</p><table><thead><tr><th align="center">常用参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-name</td><td align="center">按名称查找</td></tr><tr><td align="center">-size</td><td align="center">按大小查找</td></tr><tr><td align="center">-user</td><td align="center">按属性查找</td></tr><tr><td align="center">-type</td><td align="center">按类型查找</td></tr><tr><td align="center">-iname</td><td align="center">忽略大小写</td></tr></tbody></table><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">find /home -name &quot;*.txt&quot;</td><td align="center">在/home目录下查找以.txt结尾的文件名</td></tr><tr><td align="center">find /home -iname &quot;*.txt&quot;</td><td align="center">在/home目录下查找以.txt结尾的文件名并忽略大小写</td></tr><tr><td align="center">find . -name &quot;<em>.txt&quot; -o -name &quot;</em>.pdf&quot;</td><td align="center">当前目录及子目录下查找所有以.txt或者以.pdf结尾的文件</td></tr><tr><td align="center">find . -type f -atime -7</td><td align="center">当前目录下搜索最近七天内被访问过的所有文件</td></tr><tr><td align="center">find . -type f -atime +7</td><td align="center">当前目录下搜索超过七天内被访问过的所有文件</td></tr><tr><td align="center">find . -type f -amin +10</td><td align="center">当前目录下搜索访问时间超过10分钟的所有文件</td></tr><tr><td align="center">find . -type f -size +10k</td><td align="center">当前目录下搜索大于10KB的文件</td></tr><tr><td align="center">find . -type f -size 10M</td><td align="center">当前目录下搜索等于10MB的文件</td></tr><tr><td align="center">find . -type f -name &quot;*.txt&quot; -delete</td><td align="center">删除当前目录下所有.txt文件</td></tr><tr><td align="center">find . -name &quot;*.java&quot; ! -perm 644</td><td align="center">找出当前目录下权限不是644的java文件</td></tr><tr><td align="center">find . -perm 777</td><td align="center">当前目录下搜索出权限为777的文件和目录</td></tr><tr><td align="center">find . -user tom</td><td align="center">找出当前目录用户tom拥有的所有文件和目录</td></tr><tr><td align="center">find . -empty</td><td align="center">要列出所有长度为零的文件</td></tr><tr><td align="center">find /etc -maxdepth 4 -mindepth 2 -name passwd</td><td align="center">查找etc目录下，查找子目录最大深度为4层、最小深度为2层，并且文件名为passwd的文件或目录</td></tr><tr><td align="center">find . -type f -name ‘*.mp3’ -exec cp {} /tmp ‘;’</td><td align="center">查找当前目录下所有的MP3文件，并且复制到tmp目录</td></tr></tbody></table><p><font color="red">说明：find命令的功能和参数及其强大和复杂，这里只列出了比较常用的参数、语法和示例。详情可查阅：<a href="https://man.linuxde.net/find" title="find" target="_blank" rel="noopener">find</a></font></p></li></ol><h3 id="六、查看文件内容"><a href="#六、查看文件内容" class="headerlink" title="六、查看文件内容"></a>六、查看文件内容</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">cat [-n] 文件名</td><td align="center">显示文件内容，-n表示连行号一起显示</td></tr><tr><td align="center">less 文件名</td><td align="center">一页一页的显示文件内容（按q退出浏览）</td></tr><tr><td align="center">head [-n] 文件名</td><td align="center">显示文件头n行内容，n指定显示多少行</td></tr><tr><td align="center">tail -n 3 -f 文件名</td><td align="center">显示文件尾3行内容，并在文件更新时实时追加显示，没有-n默认10行</td></tr><tr><td align="center">sed -n ‘/tomcat/p’ 文件名</td><td align="center">显示包括关键词所在行</td></tr><tr><td align="center">less 文件名</td><td align="center">grep tomcat</td></tr></tbody></table><h3 id="七、文件处理"><a href="#七、文件处理" class="headerlink" title="七、文件处理"></a>七、文件处理</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">echo &quot;test&quot; &gt; abc.txt</td><td align="center">将字符串”test”写入（覆盖）到abc.txt文件中，原有文本内容会被覆盖，没有abc.txt文件则会创建</td></tr><tr><td align="center">echo &quot;test&quot; &gt;&gt; abc.txt</td><td align="center">将字符串”test”追加到abc.txt文本中</td></tr><tr><td align="center">wc -lwcm abc.txt</td><td align="center">统计文本信息：-l表示统计行数，-w统计单词，-c统计字节数，-m统计字符数</td></tr><tr><td align="center">vim abc.txt</td><td align="center">查看编辑文件</td></tr></tbody></table><h3 id="八、用户与权限"><a href="#八、用户与权限" class="headerlink" title="八、用户与权限"></a>八、用户与权限</h3><ol><li><p><strong>命令</strong>：useradd<br><strong>命令含义</strong>：添加用户<br><strong>语法</strong>：<strong><font color="green">useradd [options] LOGIN</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-c&lt;备注&gt;</td><td align="center">加上备注文字。备注文字会保存在passwd的备注栏位中。</td></tr><tr><td align="center">-d&lt;登入目录&gt;</td><td align="center">指定用户登入时的启始目录。</td></tr><tr><td align="center">-D</td><td align="center">变更预设值．</td></tr><tr><td align="center">-e&lt;有效期限&gt;</td><td align="center">指定帐号的有效期限。</td></tr><tr><td align="center">-f&lt;缓冲天数&gt;</td><td align="center">指定在密码过期后多少天即关闭该帐号。</td></tr><tr><td align="center">-g&lt;群组&gt;</td><td align="center">指定用户所属的群组。</td></tr><tr><td align="center">-G&lt;群组&gt;</td><td align="center">指定用户所属的附加群组。</td></tr><tr><td align="center">-m</td><td align="center">自动建立用户的登入目录。</td></tr><tr><td align="center">-M</td><td align="center">不要自动建立用户的登入目录。</td></tr><tr><td align="center">-n</td><td align="center">取消建立以用户名称为名的群组．</td></tr><tr><td align="center">-r</td><td align="center">建立系统帐号。</td></tr><tr><td align="center">-s<shell></shell></td><td align="center">指定用户登入后所使用的shell。</td></tr><tr><td align="center">-u<uid></uid></td><td align="center">指定用户ID。</td></tr></tbody></table></li><li><p><strong>命令</strong>：userdel<br><strong>命令含义</strong>：删除用户<br><strong>语法</strong>：<strong><font color="green">userdel [options] LOGIN</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-f</td><td align="center">强制删除用户，即使用户当前已登录；</td></tr><tr><td align="center">-r</td><td align="center">删除用户的同时，删除与用户相关的所有文件。</td></tr></tbody></table></li><li><p><strong>命令</strong>：usermod<br><strong>命令含义</strong>：用于修改用户账号<br><strong>语法</strong>：<strong><font color="green">usermod [options] LOGIN</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-a|–append</td><td align="center">把用户追加到某些组中，仅与-G选项一起使用</td></tr><tr><td align="center">-c|–comment</td><td align="center">修改/etc/passwd文件第五段comment</td></tr><tr><td align="center">-d|–home</td><td align="center">修改用户的家目录通常和-m选项一起使用</td></tr><tr><td align="center">-e|–expiredate</td><td align="center">指定用户帐号禁用的日期，格式YY-MM-DD</td></tr><tr><td align="center">-f|–inactive</td><td align="center">密码过期多少天后禁用该帐号，0:密码过期就禁用帐号，-1:禁用此功能，默认值是-1</td></tr><tr><td align="center">-g|–gid</td><td align="center">修改用户的gid，改组一定存在</td></tr><tr><td align="center">-G|–groups</td><td align="center">把用户追加到某些组中，仅与-a选项一起使用</td></tr><tr><td align="center">-l|–login</td><td align="center">修改用户的登录名称</td></tr><tr><td align="center">-L|–lock</td><td align="center">锁定用户的密码</td></tr><tr><td align="center">-m|–move-home</td><td align="center">修改用户的家目录通常和-d选项一起使用</td></tr><tr><td align="center">-s|–shell</td><td align="center">修改用户的shell</td></tr><tr><td align="center">-u|–uid</td><td align="center">修改用户的uid，该uid必须唯一</td></tr><tr><td align="center">-U|–unlock</td><td align="center">解锁用户的密码</td></tr></tbody></table></li><li><p><strong>命令</strong>：groupadd<br><strong>命令含义</strong>：添加组<br><strong>语法</strong>：<strong><font color="green">groupadd [options] GROUP</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-g gid</td><td align="center">指定组id</td></tr><tr><td align="center">-r</td><td align="center">创建系统组</td></tr><tr><td align="center">-f</td><td align="center">如果组已经存在，则成功退出；如果已经使用GID，则取消-g。</td></tr></tbody></table></li><li><p><strong>命令</strong>：groupdel<br><strong>命令含义</strong>：删除组<br><strong>语法</strong>：<strong><font color="green">groupdel [options] GROUP</font></strong></p></li><li><p><strong>命令</strong>：groupmod<br><strong>命令含义</strong>：用于修改组信息<br><strong>语法</strong>：<strong><font color="green">groupmod [options] GROUP</font></strong><br><strong>参数说明</strong>：</p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-g GID</td><td align="center">修改组 ID；</td></tr><tr><td align="center">-n</td><td align="center">新组名 修改组名</td></tr></tbody></table></li><li><p><strong>命令</strong>：passwd<br><strong>命令含义</strong>：用来更改用户的密码<br><strong>语法</strong>：<strong><font color="green">passwd [OPTION…] &lt;accountName&gt;</font></strong></p><table><thead><tr><th align="center">参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-k, –keep-tokens</td><td align="center">保留即将过期的用户在期满后能仍能使用；</td></tr><tr><td align="center">-d, –delete</td><td align="center">删除用户密码，仅能以root权限操作；</td></tr><tr><td align="center">-l, –lock</td><td align="center">锁住用户无权更改其密码，仅能通过root权限操作；</td></tr><tr><td align="center">-u, –unlock</td><td align="center">解除锁定；</td></tr><tr><td align="center">-f, –force</td><td align="center">强制操作；仅root权限才能操作；</td></tr><tr><td align="center">-x, –maximum=DAYS</td><td align="center">两次密码修正的最大天数，后面接数字；仅能root权限操作；</td></tr><tr><td align="center">-n, –minimum=DAYS</td><td align="center">两次密码修改的最小天数，后面接数字，仅能root权限操作；</td></tr><tr><td align="center">-w, –warning=DAYS</td><td align="center">在距多少天提醒用户修改密码；仅能root权限操作；</td></tr><tr><td align="center">-i, –inactive=DAYS</td><td align="center">在密码过期后多少天，用户被禁掉，仅能以root操作；</td></tr><tr><td align="center">-S, –status</td><td align="center">查询用户的密码状态，仅能root用户操作；</td></tr></tbody></table></li></ol><h3 id="九、磁盘管理"><a href="#九、磁盘管理" class="headerlink" title="九、磁盘管理"></a>九、磁盘管理</h3><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">df -h</td><td align="center">显示磁盘的空间使用情况 及挂载点</td></tr><tr><td align="center">df -h /var/log</td><td align="center">（显示log所在分区（挂载点）、目录所在磁盘及可用的磁盘容量）</td></tr><tr><td align="center">du -sm /var/log/* | sort -rn</td><td align="center">根据占用磁盘空间大小排序（MB）某目录下文件和目录大小</td></tr><tr><td align="center">fdisk -l</td><td align="center">查所有分区及总容量，加/dev/sda为查硬盘a的分区）</td></tr><tr><td align="center">fdisk /dev/sdb</td><td align="center">对硬盘sdb进行分区</td></tr><tr><td align="center">mount /dev/sda1 /mnt</td><td align="center">硬盘sda1挂载到/mnt目录（mount 装置文件名 挂载点）</td></tr><tr><td align="center">mount -o loop /opt/soft/CentOS-7-x86_64-DVD-1708.iso /media/CentOS</td><td align="center">挂载iso文件</td></tr><tr><td align="center">umount /dev/sda1</td><td align="center">取消挂载（umount 装置文件名或挂载点）</td></tr></tbody></table><h3 id="十、解压、缩压与打包、解包"><a href="#十、解压、缩压与打包、解包" class="headerlink" title="十、解压、缩压与打包、解包"></a>十、解压、缩压与打包、解包</h3><ol><li><p><strong>命令</strong>：tar<br><strong>命令含义</strong>：文件、目录打包、解包，并且支持将多个文件包成一个文件，同时还可通过gzip/bzip将该文件压缩。<br><strong>语法1</strong>：<strong><font color="green">tar [-czvf] 打包后文件名  文件或目录</font></strong><br><strong>语法2</strong>：<strong><font color="green">tar [-xzvf] 需要解包的文件名</font></strong><br><strong>常用参数说明</strong>：</p><table><thead><tr><th align="center">常用参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">新建打包文件，同 -v 一起使用 查看过程中打包文件名</td></tr><tr><td align="center">-C</td><td align="center">解压到对应的文件目录。</td></tr><tr><td align="center">-x</td><td align="center">解包文件</td></tr><tr><td align="center">-f</td><td align="center">后面接要处理的文件</td></tr><tr><td align="center">-j</td><td align="center">通过bzip2方式压缩或解压，最后以.tar.br2 为后缀。压缩后大小小于.tar.gz</td></tr><tr><td align="center">-z</td><td align="center">通过gzip方式压缩或解压，最后以.tar.gz 为后缀</td></tr><tr><td align="center">-v</td><td align="center">压缩或解压过程中，显示出来过程</td></tr><tr><td align="center">-t</td><td align="center">查看打包文件中内容，重点文件名</td></tr><tr><td align="center">-r</td><td align="center">添加文件到已经压缩的文件</td></tr><tr><td align="center">-u</td><td align="center">更新压缩文件中的内容。</td></tr><tr><td align="center">-p</td><td align="center">保留绝对路径，即允许备份数据中含有根目录</td></tr><tr><td align="center">-P</td><td align="center">保留数据原来权限及属性。</td></tr></tbody></table><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">tar -czvf fileName.tar.gz .</td><td align="center">压缩当前目录所有文件和目录到fileName.tar.gz包中</td></tr><tr><td align="center">tar -xzvf fileName.tar.gz</td><td align="center">解压fileName.tar.gz</td></tr><tr><td align="center">tar -tf 压缩文件名</td><td align="center">查看文件名</td></tr><tr><td align="center">tar -tvf 压缩文件</td><td align="center">查看文件：所属权限、用户名用户组、日期等</td></tr><tr><td align="center">tar -zcvf bak.tar.gz  bak.tar</td><td align="center">使用gzip将打包文件bak.tar压缩为bak.tar.gz</td></tr><tr><td align="center">tar -jcvf bak.tar.bz2  bak.tar</td><td align="center">使用bzip2将打包文件bak.tar压缩为bak.tar.bz2</td></tr><tr><td align="center">tar -rvf bak.tar /etc/password</td><td align="center">将/etc/password追加文件到bak.tar中</td></tr><tr><td align="center">tar -cvf bak.tar  .</td><td align="center">将当前目录的文件打包为bak.tar</td></tr><tr><td align="center">tar -cvf log.tar log2012.log</td><td align="center">仅打包，不压缩！</td></tr><tr><td align="center">tar -czvf log.tar.gz log2012.log</td><td align="center">打包后，以 gzip 压缩</td></tr><tr><td align="center">tar -czvf log.tar.bz2 log2012.log</td><td align="center">打包后，以 bzip2 压缩</td></tr></tbody></table><p><font color="red">说明：tar仅为打包解包命令，需要解压缩则需要跟上相应参数或指定包后缀格式</font></p></li><li><p><strong>命令</strong>：zip/unzip<br><strong>命令含义</strong>：压缩(解压)文件,压缩文件后缀为.zip<br><strong>语法1</strong>：<strong><font color="green">zip [-options] [-b path] [-t mmddyyyy] [-n suffixes] [zipfile list] [-xi list]</font></strong><br><strong>语法2</strong>：<strong><font color="green">unzip [-Z] [-opts[modifiers]] file[.zip] [list] [-x xlist] [-d exdir]</font></strong><br><strong>常用参数说明</strong>：</p><table><thead><tr><th align="center">常用参数</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">-q</td><td align="center">不显示指令执行过程。</td></tr><tr><td align="center">-r</td><td align="center">递归处理，将指定目录下的所有文件和子目录一并处理。</td></tr><tr><td align="center">-P</td><td align="center">压缩时为压缩包添加密码</td></tr><tr><td align="center">-o</td><td align="center">不必先询问用户，unzip执行后覆盖原有文件。</td></tr><tr><td align="center">-d</td><td align="center">解压时指定解压文件存放目录</td></tr><tr><td align="center">-t</td><td align="center">检查压缩文件是否正确。</td></tr><tr><td align="center">-j</td><td align="center">不处理压缩文件中原有的目录路径。</td></tr></tbody></table><p><strong>示例</strong>：</p><table><thead><tr><th align="center">示例</th><th align="center">示例说明</th></tr></thead><tbody><tr><td align="center">zip -r fileName.zip a目录</td><td align="center">把a目录以及子目录压缩为fileName.zip</td></tr><tr><td align="center">unzip fileName.zip -d a目录</td><td align="center">fileName.zip解压到a目录里面</td></tr><tr><td align="center">zip -r abc123.zip abc 123.txt</td><td align="center">把abc文件夹和123.txt压缩成为abc123.zip</td></tr><tr><td align="center">unzip fileName.zip</td><td align="center">把fileName.zip直接解压到当前目录下</td></tr><tr><td align="center">unzip abc*.zip</td><td align="center">把abc12.zip、abc23.zip、abc34.zip同时解压到当前目录</td></tr><tr><td align="center">unzip -v fileName.zip</td><td align="center">查看把/home目录下面的fileName.zip里面的内容</td></tr><tr><td align="center">unzip -t fileName.zip</td><td align="center">验证fileName.zip是否完整</td></tr><tr><td align="center">unzip -j fileName.zip</td><td align="center">把fileName.zip里面的所有文件解压到第一级目录</td></tr></tbody></table></li></ol><h3 id="十一、其他常用命令"><a href="#十一、其他常用命令" class="headerlink" title="十一、其他常用命令"></a>十一、其他常用命令</h3><ol><li><strong>通用命令</strong>：<table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">ls -l|grep &quot;^-&quot;| wc -l</td><td align="center">查看当前目录下的文件数量（不包含子目录中的文件）</td></tr><tr><td align="center">last</td><td align="center">显示近期用户或终端的成功登录情况。</td></tr><tr><td align="center">echo &gt; /var/log/wtmp</td><td align="center">清除登陆系统成功的记录(此文件默认打开时乱码)</td></tr><tr><td align="center">lastb</td><td align="center">记录失败的登录尝试</td></tr><tr><td align="center">echo &gt; /var/log/btmp</td><td align="center">清除登陆系统失败的记录</td></tr><tr><td align="center">history -c</td><td align="center">清除历史执行命令</td></tr><tr><td align="center">echo 3 &gt; /proc/sys/vm/drop_caches</td><td align="center">释放缓存空间</td></tr></tbody></table></li></ol><ol start="2"><li><strong>适用于CentOS、RedHat系统</strong><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">yum install 软件</td><td align="center">安装软件</td></tr><tr><td align="center">yum list installed |grep java</td><td align="center">列出已安装的java软件</td></tr><tr><td align="center">yum remove java-1.8.0-openjdk.x86_64</td><td align="center">卸载软件（卸载JDK）</td></tr><tr><td align="center">yum update [软件]</td><td align="center">更新软件、软件库</td></tr><tr><td align="center">wget -P /usr/local https://网址</td><td align="center">下载文件到指定目录</td></tr><tr><td align="center">rpm -ivh wps-office-版本.x86_64.rpm</td><td align="center">安装rpm包（包要先下载并且要先装依赖包，这里推荐使用yum安装软件可自动下载依赖包）</td></tr></tbody></table></li></ol><ol start="3"><li><strong>适用于适用于Ubuntu、Debian系统系统</strong><table><thead><tr><th align="center">命令</th><th align="center">命令含义</th></tr></thead><tbody><tr><td align="center">apt-get install 软件</td><td align="center">安装软件</td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置浅谈-configure的参数配置说明</title>
      <link href="/2019/09/20/nginx%E9%85%8D%E7%BD%AE%E6%B5%85%E8%B0%88-configure%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/"/>
      <url>/2019/09/20/nginx%E9%85%8D%E7%BD%AE%E6%B5%85%E8%B0%88-configure%E7%9A%84%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><table><thead><tr><th align="center">序号</th><th align="center">参数格式</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">–prefix=path</td><td align="center">定义安装目录</td></tr><tr><td align="center">2</td><td align="center">–sbin-path=path</td><td align="center">设置nginx可执行文件的路径</td></tr><tr><td align="center">3</td><td align="center">–modules-path=path</td><td align="center">定义将安装nginx动态模块的目录</td></tr><tr><td align="center">4</td><td align="center">–conf-path=path</td><td align="center">设置nginx.conf配置文件路径名</td></tr><tr><td align="center">5</td><td align="center">–error-log-path=path</td><td align="center">设置主要错误，警告和诊断文件的路径名</td></tr><tr><td align="center">6</td><td align="center">–pid-path=path</td><td align="center">设置nginx.pid将存储主进程的进程ID 的文件的路径名</td></tr><tr><td align="center">7</td><td align="center">–lock-path=path</td><td align="center">为锁定文件的名称设置前缀</td></tr><tr><td align="center">8</td><td align="center">–user=name</td><td align="center">设置非特权用户的名称，其凭据将由工作进程使用</td></tr><tr><td align="center">9</td><td align="center">–group=name</td><td align="center">设置其凭据将由工作进程使用的组的名称</td></tr><tr><td align="center">10</td><td align="center">–build=name</td><td align="center">设置编译名</td></tr><tr><td align="center">11</td><td align="center">-builddir=path</td><td align="center">置编译目录</td></tr><tr><td align="center">12</td><td align="center">–with-select_module、–without-select_module</td><td align="center">启用或禁用select事件驱动模型</td></tr><tr><td align="center">13</td><td align="center">–with-poll_module、–without-poll_module</td><td align="center">启用或禁用poll事件驱动模型</td></tr><tr><td align="center">14</td><td align="center">–with-threads</td><td align="center">启用线程池功能</td></tr><tr><td align="center">15</td><td align="center">–with-file-aio</td><td align="center">我们就可以启用线程池功能，让请求排队等待处理，并且可以充分利用CPU提高处理效率。开启线程池需要AIO的支持。 启用异步文件IO（AIO）支持。一般用于大文件传输的场景下。</td></tr><tr><td align="center">16</td><td align="center">–with-http_ssl_module</td><td align="center">将HTTPS协议支持添加到HTTP服务器。默认情况下不构建此模块。需要OpenSSL库来构建和运行此模块。</td></tr><tr><td align="center">17</td><td align="center">–with-http_v2_module</td><td align="center">启用HTTP_V2模块，新的HTTP协议，相比HTTP1更优更快。默认情况下不构建此模块。</td></tr><tr><td align="center">18</td><td align="center">–with-http_realip_module</td><td align="center">启用HTTP_Realip模块，用于修改客户端请求头中客户端IP地址值，一般用于反向代理中，将真实的客户端IP传送给后端的应用服务器。默认情况下不构建此模块。</td></tr><tr><td align="center">19</td><td align="center">–with-http_addition_module</td><td align="center">启用HTTP_Addition模块，用于在响应之前和之后添加文本。默认情况下不构建此模块。</td></tr><tr><td align="center">20</td><td align="center">–with-http_xslt_module</td><td align="center">启用HTTP_Xslt模块，这个模块是一个过滤器，它可以通过XSLT模板转换成XML响应。需要ibxml2和libxslt库的支持。默认情况下不构建此模块。</td></tr><tr><td align="center">21</td><td align="center">–with-http_xslt_module=dynamic</td><td align="center">启用HTTP_Xslt动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">22</td><td align="center">–with-http_image_filter_module</td><td align="center">启用HTTP_Image_Filter模块，这个模块是一个集成图片处理器，我们可以使用它转换JPEG、GIF、PNG和WEBP格式的图像，验证这些格式图像的有效型（是不是此格式的图像），输出JSON格式的图像信息，旋转图像，按比例缩放图像，剪切图片等。默认情况下不构建此模块。</td></tr><tr><td align="center">23</td><td align="center">–with-http_image_filter_module=dynamic</td><td align="center">启用HTTP_Image_Filter动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">24</td><td align="center">–with-http_geoip_module</td><td align="center">启用HTTP_Geoip模块，这个模块用于处理不同地区的访问，当来自某一个区域的访问时将其重定向到对应的服务或者项目上，需要MaxMind GeoIP库的支持。默认情况下不构建此模块。</td></tr><tr><td align="center">25</td><td align="center">–with-http_geoip_module=dynamic</td><td align="center">启用HTTP_Geoip动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">26</td><td align="center">–with-http_sub_module</td><td align="center">启用HTTP_Sub模块，这个模块是一个过滤器，用于修改响应的内容，可以将一个指定的字符串替换成另一个字符串。默认情况下不构建此模块。</td></tr><tr><td align="center">27</td><td align="center">–with-http_dav_module</td><td align="center">启用HTTP_DAV模块，用于通过WEBDAV协议提供WEB的文件管理功能，类似于一个WEB的文件管理器，可以对服务器的文件进行管理。默认情况下不构建此模块。</td></tr><tr><td align="center">28</td><td align="center">–with-http_flv_module</td><td align="center">启用HTTP_FLV模块，用于为Flash Video（FLV）文件提供伪流视频服务端支持，开启它则允许在网页上播放FLV格式的视频。默认情况下不构建此模块。</td></tr><tr><td align="center">29</td><td align="center">–with-http_mp4_module</td><td align="center">启用HTTP_MP4模块，用于为MP4格式的视频文件提供伪流视频服务端支持，开启它则允许在网页上播放MP4格式的视频。默认情况下不构建此模块。</td></tr><tr><td align="center">30</td><td align="center">–with-http_gunzip_module</td><td align="center">启用HTTP_Gunzip模块，用于为不支持”gzip”编码方式的客户端解压响应。</td></tr><tr><td align="center">31</td><td align="center">–with-http_gzip_static_module</td><td align="center">启用HTTP_Gzip_Static模块，用于将静态内容压缩成”.gz”为文件扩展名的预压缩文件，并缓存在本地，在响应时会将此文件发送以替代普通文件。</td></tr><tr><td align="center">32</td><td align="center">–with-http_auth_request_module</td><td align="center">启用HTTP_Auth_Request模块，此模块是一个请求验证模块，可以使用外部服务器或服务对网站的每个请求进行身份验证。当用户访问时，Nginx会向用于验证请求的外部服务器发出验证请求，若返回的状态码为200，则通过允许访问，若返回401或403，则访问会被拒绝。默认情况下不构建此模块。</td></tr><tr><td align="center">33</td><td align="center">–with-http_random_index_module</td><td align="center">启用HTTP_Random_Index模块，随机主页模块，当用户访问时，随机响应一个主页，而并非由”index”指令定义的一个主页，而是从主页池中随机选中一个主页面返回。默认情况下不构建此模块。</td></tr><tr><td align="center">34</td><td align="center">–with-http_secure_link_module</td><td align="center">启用HTTP_Secure_Link模块，防盗链模块，用于检查请求链接的权限以及是否过期，多用于文件下载防盗链。默认情况下不构建此模块。</td></tr><tr><td align="center">35</td><td align="center">–with-http_degradation_module</td><td align="center">启用HTTP_Degradation模块，用于当主机剩余内存较低时，用户请求访问，Nginx会对某些”location”的请求返回204或444的响应码。默认情况下不构建此模块。</td></tr><tr><td align="center">36</td><td align="center">–with-http_slice_module</td><td align="center">启用HTTP_Slice模块，此模块是一个过滤器，用于将一个大的完整的文件分割成多个小块文件，分段传送给用户，一般用于大文件传输的场景下，使用它可以让用户快速的得到响应。默认情况下不构建此模块。</td></tr><tr><td align="center">37</td><td align="center">–with-http_stub_status_module</td><td align="center">启用HTTP_Stub_Status模块，状态信息统计模块，用于返回一个Nginx状态信息统计信息页面，管理员访问这个页面可以获取Nginx的请求处理、当前连接、等待连接等统计信息，一般用于监控Nginx的运行状态。默认情况下不构建此模块。</td></tr><tr><td align="center">38</td><td align="center">–without-http_charset_module</td><td align="center">禁用HTTP_Charset模块，此模块用于将指定的字符集添加到”Content-Type”响应头字段中。此外此模块还可以将数据从一个字符集转换为另一个字符集，此模块用于字符集设置。不建议禁用。</td></tr><tr><td align="center">39</td><td align="center">–without-http_gzip_module</td><td align="center">禁用HTTP_Gzip模块，此模块用于HTTP响应内容传输压缩，可以将响应内存在传输时将其压缩成Gzip编码格式的响应传送给客户端，使用Gzip编码格式响应内容体积会变小，会提高传输效率。不建议禁用。</td></tr><tr><td align="center">40</td><td align="center">–without-http_ssi_module</td><td align="center">禁用HTTP_SSI模块，此模块是一个过滤器，用于处理通过它响应中的SSI（Server Side Includes）命令。目前支持的SSI命令列表并不完整，SSI指令是一种可以嵌入WEB页面的一种语法指令。</td></tr><tr><td align="center">41</td><td align="center">–without-http_userid_module</td><td align="center">禁用HTTP_Userid模块，此模块用于识别客户端的Cookie。可以使用嵌入变量”$uid_got”和”$uid_set”记录已接受和设置的Cookie。</td></tr><tr><td align="center">42</td><td align="center">–without-http_access_module</td><td align="center">禁用HTTP_Access模块，此模块用于限制对某些客户端地址的访问，Allow or Deny。不建议禁用。</td></tr><tr><td align="center">43</td><td align="center">–without-http_auth_basic_module</td><td align="center">禁用HTTP_Auth_Basic模块，该模块用于HTTP基本身份验证，使用用户名和密码来限制对资源的访问。</td></tr><tr><td align="center">44</td><td align="center">–without-http_mirror_module</td><td align="center">禁用HTTP_Mirror模块，该模块用于将正式环境的流量拷贝到镜像（测试）环境下，一般用于测试环境引入真实环境的流量实现对测试环境的压力测试。</td></tr><tr><td align="center">45</td><td align="center">–without-http_autoindex_module</td><td align="center">禁用HTTP_Autoindex模块，该模块用于在处理以斜杠字符（’/‘）结尾的请求，并在找不到索引文件的情况下生成目录列表。</td></tr><tr><td align="center">46</td><td align="center">–without-http_geo_module</td><td align="center">禁用HTTP_Geo模块，该模块用于从指定变量中获取客户端的IP地址，并将其嵌入到另外一个变量中。默认情况下从”$remote_addr”变量中取得客户端的IP地址。我们可以通过它结合”HTTP_Upstream”实现对来源客户端的负载均衡，当来自不同的客户端请求时，将其负载均衡给后端的不同的服务器处理；还可以使用它结合”HTTP_Map”+”HTTP_Limit_Conn”模块实现对来源客户端的限速功能。</td></tr><tr><td align="center">47</td><td align="center">–without-http_map_module</td><td align="center">禁用HTTP_Map模块，该模块用于创建一个变量的映射表，结果变量可以是一个字符串也可以是另外一个变量。</td></tr><tr><td align="center">48</td><td align="center">–without-http_split_clients_module</td><td align="center">禁用HTTP_Splic_Clients模块，该模块用于创建适用于A/B测试的变量，AB测试也称之为拆分测试，也就是将一个项目的两个不同版本发布，看用户更喜欢用于那个版本，若版本A受欢迎则发布版本A。</td></tr><tr><td align="center">49</td><td align="center">–without-http_referer_module</td><td align="center">禁用HTTP_Referer模块，该模块用于防盗链，用于阻止对请求头部”referer”字段具有无效值的请求访问，可以设置一个白名单，非白名单的无效来源网址的连接则会拒绝请求，使用此模块我们还需考虑到，即使对于有效的请求，常规浏览器也可能不发送”referer”字段。不建议禁用。</td></tr><tr><td align="center">50</td><td align="center">–without-http_rewrite_module</td><td align="center">禁用HTTP_Rewerte模块，该模块用于地址重写，用于将来源请求地址重定向到指定的地址上，可以保护真实的地址，增加安全性，该模块需要PCRE库的支持。不建议禁用。</td></tr><tr><td align="center">51</td><td align="center">–without-http_proxy_module</td><td align="center">禁用HTTP_Proxy模块，该模块用于将请求代理传递到另外一台WEB服务器去处理，Nginx的核心模块。不建议禁用。</td></tr><tr><td align="center">52</td><td align="center">–without-http_fastcgi_module</td><td align="center">禁用HTTP_FastCGI模块，该模块用于将请求代理传递到另外一台FastCGI服务器去处理，一般用于反代PHP。不建议禁用。</td></tr><tr><td align="center">53</td><td align="center">–without-http_uwsgi_module</td><td align="center">禁用HTTP_UwSGI模块，该模块用于将请求代理传递给另外一台UwSGI服务器去处理。</td></tr><tr><td align="center">54</td><td align="center">–without-http_scgi_module</td><td align="center">禁用HTTP_SCGI模块，该模块用于将请求代理传递给另外一台SCGI服务器去处理。</td></tr><tr><td align="center">55</td><td align="center">–without-http_grpc_module</td><td align="center">禁用HTTP_Grpc模块，该模块用于将请求代理传递给另外一台Grpc服务器去处理。</td></tr><tr><td align="center">56</td><td align="center">–without-http_memcached_module</td><td align="center">禁用HTTP_Memcached模块，该模块用于Nginx从Memcached服务器获取响应内容。</td></tr><tr><td align="center">57</td><td align="center">–without-http_limit_conn_module</td><td align="center">禁用HTTP_Limit_Conn模块，该模块用于限制并发连接数量以及下载带宽限制。</td></tr><tr><td align="center">58</td><td align="center">–without-http_limit_req_module</td><td align="center">禁用HTTP_Limit_Req模块，该模块用于限制请求数量，可以限制请求的频率。</td></tr><tr><td align="center">59</td><td align="center">–without-http_empty_gif_module</td><td align="center">禁用HTTP_Empty_Gif模块，该模块会在内容中常驻的一个1X1的透明空白的GIF图像，当用户请求时，返回该图像，一般用于测试。</td></tr><tr><td align="center">60</td><td align="center">–without-http_browser_module</td><td align="center">禁用HTTP_Browser模块，该模块用于创建变量，变量的值取决于请求头中”user-agent”的值，一般用于区别新式或者旧式浏览器，若新式浏览器则将请求重定向到新式的WEB页面中，呈现新页面，若为旧式浏览器则将返回旧式的WEB页面。</td></tr><tr><td align="center">61</td><td align="center">–without-http_upstream_hash_module</td><td align="center">禁用HTTP_Upstream_Hash模块，该模块提供了由”Upstream”指令定义的一组服务器的负载均衡方法”Hash”，该方法基于散列键值（hash），它会将客户端+服务端的映射关系存放到一个散列键值表中，当客户端第二次请求时则会匹配关系将请求转发至后端的同一台服务器上，实现会话保持功能。该模块提供指令”hash”,在会话保持中，我们唯一能标识客户端的标志就是SessionID，所以我们可以使用指令”hash $cookie_jsession”实现会话保持功能。不建议禁用。</td></tr><tr><td align="center">62</td><td align="center">–without-http_upstream_ip_hash_module</td><td align="center">禁用HTTP_Upstream_IP_Hash模块，该模块提供了由”Upstream”指令定义的一组服务器的负载均衡方法”ip_hash”，该方法也用于会话保持，不过它是基于客户端IP的Hash方法，由于用户可能是ADSL接入的网络，所以客户端可能受动态IP影响会发生变化，所以一般不建议采用这种方法。</td></tr><tr><td align="center">63</td><td align="center">–without-http_upstream_least_conn_module</td><td align="center">禁用HTTP_Upstream_Least_Conn模块，该模块提供了由”Upstream”指令定义的一组服务器的负载均衡方法”least_conn”，该方法用于将请求传递到具有最少活动连接、权重较高（性能最好）的后端服务器上去处理。</td></tr><tr><td align="center">64</td><td align="center">–without-http_upstream_keepalive_module</td><td align="center">禁用HTTP_Upstream_Keepalive模块，该模块可以为由”Upstream”指令定义的一组服务器提供保持长连接的功能，使用它则会为每个Worker工作进程与后端服务器保持空闲的长连接，连接数由”keepalive”指令指定，当空闲的长连接数量超过指定值时，将关闭最近最少使用的连接。</td></tr><tr><td align="center">65</td><td align="center">–without-http_upstream_zone_module</td><td align="center">禁用HTTP_Upstream_Zone模块，该模块可以将由”Upstream”指令定义的服务器组运行时的状态存储在共享内存区域中。</td></tr><tr><td align="center">66</td><td align="center">–with-http_perl_module、–with-http_perl_module=dynamic</td><td align="center">启用HTTP_Perl模块，用于在Perl中实现位置和变量处理程序，并可以将Perl调用到SSI中。默认情况下不构建此模块。 启用HTTP_Perl动态模块，允许在配置文件中通过”load_module”指定手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">67</td><td align="center">–with-perl_modules_path=PATH</td><td align="center">置一个用于保留Perl模块的目录路径。</td></tr><tr><td align="center">68</td><td align="center">–with-perl=PATH</td><td align="center">设置Perl可执行命令文件的路径。</td></tr><tr><td align="center">69</td><td align="center">–http-log-path=PATH</td><td align="center">设置访问日志文件存放目录路径。安装后，可以在主配置文件中使用”access_log”指令修改。</td></tr><tr><td align="center">70</td><td align="center">–http-client-body-temp-path=PATH</td><td align="center">设置用于存储客户端请求主体的临时文件存放目录路径。安装后，可以在主配置文件中使用”client_body_temp_path”指令修改。</td></tr><tr><td align="center">71</td><td align="center">–http-proxy-temp-path=PATH</td><td align="center">设置用于存储从代理服务器接受的数据临时文件存放目录路径。安装后，可以在主配置文件中使用”proxy_temp_path”指令修改。</td></tr><tr><td align="center">72</td><td align="center">–http-fastcgi-temp-path=PATH</td><td align="center">设置用于存储从FastCGI服务器接受的数据临时文件存放目录路径。安装后，可以在主配置文件中使用”fastcgi_temp_path”指令修改。</td></tr><tr><td align="center">73</td><td align="center">–http-uwsgi-temp-path=PATH</td><td align="center">设置用于存储从UwSGI服务器接受的数据临时文件存放目录路径。安装后，可以在主配置文件中使用”uwsgi_temp_path”指令修改。</td></tr><tr><td align="center">74</td><td align="center">–http-scgi-temp-path=PATH</td><td align="center">设置用于存储从SCGI服务器接受的数据临时文件存放目录路径。安装后，可以在主配置文件中使用”scgi_temp_path”指令修改。</td></tr><tr><td align="center">75</td><td align="center">–without-http</td><td align="center">禁用HTTP_Core模块，该模块为Nginx的核心模块，用于提供HTTP服务所有核心功能。</td></tr><tr><td align="center">76</td><td align="center">–without-http-cache</td><td align="center">禁用HTTP缓存。</td></tr><tr><td align="center">77</td><td align="center">–with-mail</td><td align="center">启用HTTP_Mail_Core模块，该模块为Nginx的核心模块，用于提供POP3/IMAP4/SMTP邮件代理服务。默认情况下不构建此模块。</td></tr><tr><td align="center">78</td><td align="center">–with-mail=dynamic</td><td align="center">启用HTTP_Mail_Core动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">79</td><td align="center">–with-mail_ssl_module</td><td align="center">启用Mail_SSL模块，用于邮件代理服务支持SSL/TLS协议，需要OpenSSL库的支持。默认情况下不构建此模块。</td></tr><tr><td align="center">80</td><td align="center">–without-mail_pop3_module</td><td align="center">禁用Mail_POP3模块，当启用HTTP_Mail_Core模块时，若你不想使用POP3协议，则可以考虑单独禁用此模块。不建议禁用。</td></tr><tr><td align="center">81</td><td align="center">–without-mail_imap_module</td><td align="center">禁用Mail_IMAP模块，当启用HTTP_Mail_Core模块时，若你不想使用IMAP4协议，则可以考虑单独禁用此模块。不建议禁用。</td></tr><tr><td align="center">82</td><td align="center">–without-mail_smtp_module</td><td align="center">禁用Mail_SMTP模块，当启用HTTP_Mail_Core模块时，若你不想使用SMTP协议，则可以考虑单独禁用此模块。不建议禁用。</td></tr><tr><td align="center">83</td><td align="center">–with-stream</td><td align="center">启用Stream_Core模块，Nginx的核心模块，用于实现TCP/UDP代理和四层负载均衡功能。默认情况下不构建此模块。此模块自Nginx1.9.0版本开始可用。</td></tr><tr><td align="center">84</td><td align="center">–with-stream=dynamic</td><td align="center">启用Stream_Core动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">85</td><td align="center">–with-stream_ssl_module</td><td align="center">启用Stream_SSL模块，用于提供SSL/TLS协议支持，需要OpenSSL库的支持。该模块用于Nginx四层负载功能中使用，需要开启Stream_Core模块。默认情况下不构建此模块。</td></tr><tr><td align="center">86</td><td align="center">–with-stream_realip_module</td><td align="center">启用Stream_Realip模块，用于修改客户端请求头中客户端IP地址值，一般用于反向代理中，将真实的客户端IP传送给后端的应用服务器。该模块用于Nginx四层负载功能中使用，需要开启Stream_Core模块。默认情况下不构建此模块。</td></tr><tr><td align="center">87</td><td align="center">–with-stream_geoip_module</td><td align="center">启用Stream_Geoip模块，用于处理不同地区的访问，当来自某一个区域的访问时将其重定向到对应的服务或者项目上，需要MaxMind GeoIP库的支持。该模块用于Nginx四层负载功能中使用，需要开启Stream_Core模块。默认情况下不构建此模块。</td></tr><tr><td align="center">88</td><td align="center">–with-stream_geoip_module=dynamic</td><td align="center">启用Stream_Geoip动态模块，允许在配置文件中通过”load_module”指令手动启用和禁用模块的使用。默认情况下不构建此模块。</td></tr><tr><td align="center">89</td><td align="center">–with-stream_ssl_preread_module</td><td align="center">启用Stream_SSL_Preread模块，用于从客户端Hello消息中提取信息，而不会终止SSL/TLS。该模块用于Nginx四层负载功能中使用，需要开启Stream_Core模块。默认情况下不构建此模块。</td></tr><tr><td align="center">90</td><td align="center">–without-stream_limit_conn_module</td><td align="center">禁用Stream_Limit_Conn模块，该模块用于限制并发连接数量以及下载带宽限制功能。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">91</td><td align="center">–without-stream_access_module</td><td align="center">禁用Stream_Access模块，该模块用于限制对某些客户端地址的访问。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">92</td><td align="center">–without-stream_geo_module</td><td align="center">禁用Stream_Geo模块，该模块用于从指定变量中获取客户端的IP地址，并将其嵌入到另外一个变量中。默认情况下从”$remote_addr”变量中取得客户端的IP地址。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">93</td><td align="center">–without-stream_map_module</td><td align="center">禁用Stream_Map模块，该模块用于创建一个变量的映射表，结果变量可以是一个字符串也可以是另外一个变量。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">94</td><td align="center">–without-stream_split_clients_module</td><td align="center">禁用Stream_Splic_Clients模块，该模块用于创建适用于A/B测试的变量，AB测试也称之为拆分测试，也就是将一个项目的两个不同版本发布，看用户更喜欢用于那个版本，若版本A受欢迎则发布版本A。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。</td></tr><tr><td align="center">95</td><td align="center">–without-stream_return_module</td><td align="center">禁用Stream_Return模块，该模块用于向客户端发送指定值，然后关闭连接。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">96</td><td align="center">–without-stream_upstream_hash_module</td><td align="center">禁用Stream_Upstream_Hash模块，该模块提供四层负载均衡的一种调度方法，一般用于基于SessionID的会话保持场景下，当开启Stream_Core模块时自动开启此功能。不建议禁用。</td></tr><tr><td align="center">97</td><td align="center">–without-stream_upstream_least_conn_module</td><td align="center">禁用Stream_Upstream_IP_Hash模块，该模块提供四层负载均衡的一种调度方法，基于来源IP的会话保持方法，由于来源IP的不稳定性，我们一般很少采用此种方法。当开启Stream_Core模块时自动开启此功能。</td></tr><tr><td align="center">98</td><td align="center">–without-stream_upstream_zone_module</td><td align="center">禁用Stream_Upstream_Zone模块，该模块可以将由”Upstream”指令定义的服务器组运行时的状态存储在共享内存区域中。该模块用于Nginx四层负载功能中使用，当开启Stream_Core模块时自动开启此功能。</td></tr><tr><td align="center">99</td><td align="center">–with-google_perftools_module</td><td align="center">启用Google_Perftools模块，用于可以使用Google Performance Tools分析Nginx的工作进程，分析程序性能瓶颈。该模块适用于Nginx开发人员，默认情况下不构建此模块。</td></tr><tr><td align="center">100</td><td align="center">–with-cpp_test_module</td><td align="center">启用Cpp_Test模块，用于C++测试。该模块适用于Nginx开发人员，默认情况下不构建此模块。</td></tr><tr><td align="center">101</td><td align="center">–add-module=PATH</td><td align="center">添加第三方模块，需要指定第三方模块所在目录路径。</td></tr><tr><td align="center">102</td><td align="center">–add-dynamic-module=PATH</td><td align="center">添加第三方动态模块，需要指定第三方动态模块所在目录路径。</td></tr><tr><td align="center">103</td><td align="center">–with-compat</td><td align="center">启用动态模块兼容性。</td></tr><tr><td align="center">104</td><td align="center">–with-cc=PATH</td><td align="center">设置GCC编译器所在目录路径。</td></tr><tr><td align="center">105</td><td align="center">–with-cpp=PATH</td><td align="center">设置GCC-C++编译器所在目录路径。</td></tr><tr><td align="center">106</td><td align="center">–with-cc-opt=OPTIONS</td><td align="center">设置将添加到CFLAGS变量的其他参数</td></tr><tr><td align="center">107</td><td align="center">–with-ld-opt=OPTIONS</td><td align="center">设置将在连接期间使用的其他参数</td></tr><tr><td align="center">108</td><td align="center">–with-cpu-opt=CPU</td><td align="center">设置CPU型号，为特定的CPU执行编译操作，有效的值：pentium, pentiumpro, pentium3, pentium4, athlon, opteron, sparc32, sparc64,ppc64。</td></tr><tr><td align="center">109</td><td align="center">–without-pcre</td><td align="center">禁用PCRE库的使用。</td></tr><tr><td align="center">110</td><td align="center">–with-pcre</td><td align="center">启用PCRE库的使用。PCRE库是一个Perl库，包含Perl兼容的正则表达式。</td></tr><tr><td align="center">111</td><td align="center">–with-pcre=DIR</td><td align="center">若你是源码安装的PCRE库，则需要通过此项设置PCRE库的所在目录路径。</td></tr><tr><td align="center">112</td><td align="center">–with-pcre-opt=OPTIONS</td><td align="center">为PCRE设置其他要编译的选项。</td></tr><tr><td align="center">113</td><td align="center">–with-pcre-jit</td><td align="center">启用”即时编译”的支持，开启此项，则会利用”pcre_jit”指令快速编译PCRE库。</td></tr><tr><td align="center">114</td><td align="center">–with-zlib=DIR</td><td align="center">若你是源码安装的Zlib库，则需要通过此项设置Zlib库的所在目录路径。当启用HTTP_Gzip模块的时候需要此库的支持。</td></tr><tr><td align="center">115</td><td align="center">–with-zlib-opt=OPTIONS</td><td align="center">为Zlib设置其他要编译的选项。</td></tr><tr><td align="center">116</td><td align="center">–with-zlib-asm=CPU</td><td align="center">为Zlib库的编译设置特定CPU，会加快编译速度，有效值：pentium, pentiumpro。</td></tr><tr><td align="center">117</td><td align="center">–with-libatomic</td><td align="center">启用Libatomic_Ops库的使用。</td></tr><tr><td align="center">118</td><td align="center">–with-libatomic=DIR</td><td align="center">若你是源码安装的Libatomic_Ops库，则需要通过此项设置Libatomic_Ops库的所在目录路径。</td></tr><tr><td align="center">119</td><td align="center">–with-openssl=DIR</td><td align="center">若你是源码安装的OpenSSL库，则需要通过此项设置OpenSSL库的所在目录路径。</td></tr><tr><td align="center">120</td><td align="center">–with-openssl-opt=OPTIONS</td><td align="center">为OpenSSL设置其他要编译的选项。</td></tr><tr><td align="center">121</td><td align="center">–with-debug</td><td align="center">启用调试级别的日志。也可以手动修改主配置文件，使用”error_log /path/to/log debug;”指令设置调试级别的日志。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> linux </tag>
            
            <tag> 说明书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nginx配置浅谈-nginx.conf</title>
      <link href="/2019/09/17/nginx%E9%85%8D%E7%BD%AE%E6%B5%85%E8%B0%88-nginx-conf/"/>
      <url>/2019/09/17/nginx%E9%85%8D%E7%BD%AE%E6%B5%85%E8%B0%88-nginx-conf/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>nginx.conf配置总体说明以及示例；</li><li>nginx安装；</li><li>源码编译构建nginx时配置参数详细说明；</li><li>nginx.conf中的负载均衡的配置详解；</li><li>nginx的访问权限配置(基于ip和账号密码的两种方式)；</li><li>https的访问配置；</li><li>新增stream模块以支持tcp代理(2019.12.03)；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>使用到linux系统：CentOS 7.2；</li><li>使用到的nginx版本：1.15.2；</li></ol><h3 id="三、nginx-conf配置总体说明以及示例"><a href="#三、nginx-conf配置总体说明以及示例" class="headerlink" title="三、nginx.conf配置总体说明以及示例"></a>三、nginx.conf配置总体说明以及示例</h3><ol><li><strong><font color="green">全局块</font></strong>：配置影响nginx全局的指令。一般有运行nginx服务器的用户组，nginx进程pid存放路径，日志存放路径，配置文件引入，允许生成worker process数等。</li><li><strong><font color="green">events块</font></strong>：配置影响nginx服务器或与用户的网络连接。有每个进程的最大连接数，选取哪种事件驱动模型处理连接请求，是否允许同时接受多个网路连接，开启多个网络连接序列化等。</li><li><strong><font color="green">http块</font></strong>：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。如文件引入，mime-type定义，日志自定义，是否使用sendfile传输文件，连接超时时间，单连接请求数等。</li><li><strong><font color="green">server块</font></strong>：配置虚拟主机的相关参数，一个http中可以有多个server。</li><li><strong><font color="green">location块</font></strong>：配置请求的路由，以及各种页面的处理情况。</li><li><strong><font color="green">upstream块</font></strong>：用来配置后台服务器负载均衡用的。<br><a href="http://staticfile.erdongchen.top/download/config.example.conf?n=nginx" title="点击下载nginx.conf" target="_blank" rel="noopener"><strong><font color="purple">nginx.conf配置文件示例下载</font></strong></a><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190917/config.example.png" align="left/"></li></ol><h3 id="四、nginx安装"><a href="#四、nginx安装" class="headerlink" title="四、nginx安装"></a>四、nginx安装</h3><ol><li>安装编译环境<pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> gccyum -y <span class="token function">install</span> gcc++yum -y <span class="token function">install</span> gcc-c++yum -y <span class="token function">install</span> <span class="token function">wget</span>yum -y <span class="token function">install</span> pcre-develyum -y <span class="token function">install</span> zlib zlib-devel<span class="token comment" spellcheck="true"># https配置需要</span>yum -y <span class="token function">install</span> openssl openssl-devel</code></pre></li><li>下载nginx安装包<br>建议下载稳定版本（Stable version）：<a href="http://nginx.org/en/download.html" title="点击下载" target="_blank" rel="noopener">nginx官网下载</a>,然后把包上传到linux上<br><font color="red">或者</font>在linux使用如下命令下载nginx-1.16.1安装包：<pre class=" language-bash"><code class="language-bash"><span class="token function">wget</span> http://nginx.org/download/nginx-1.16.1.tar.gz</code></pre></li><li>解压nginx安装包<pre class=" language-bash"><code class="language-bash"><span class="token function">tar</span> -xzvf nginx-1.16.1.tar.gz -C /usr/local/</code></pre><font color="green">参数 -C 解压到指定路径下</font></li><li>源码编译安装nginx<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 进入nginx目录</span><span class="token function">cd</span> /usr/local/nginx-1.16.1<span class="token comment" spellcheck="true"># 小白推荐执行命令</span><span class="token function">bash</span> configure<span class="token comment" spellcheck="true"># 老鸟推荐执行脚本(带https配置、可自定义配置各类参数)</span><span class="token function">bash</span> configure --prefix<span class="token operator">=</span>/usr/local/nginx --sbin-path<span class="token operator">=</span>/usr/local/nginx/sbin/nginx --conf-path<span class="token operator">=</span>/usr/local/nginx/conf/nginx.conf --error-log-path<span class="token operator">=</span>/usr/local/nginx/logs/error.log --http-log-path<span class="token operator">=</span>/usr/local/nginx/logs/access.log --pid-path<span class="token operator">=</span>/usr/local/nginx/logs/nginx.pid --lock-path<span class="token operator">=</span>/usr/local/nginx/lock/nginx.lock --user<span class="token operator">=</span>root --group<span class="token operator">=</span>root --with-http_ssl_module --with-http_realip_module --with-http_stub_status_module --with-http_gzip_static_module  --with-debug --http-client-body-temp-path<span class="token operator">=</span>/usr/local/nginx/temp --with-stream<span class="token comment" spellcheck="true"># 执行命令</span><span class="token function">make</span><span class="token comment" spellcheck="true"># 执行make install命令</span><span class="token function">make</span> <span class="token function">install</span></code></pre></li><li>配置环境变量<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 编辑  /etc/profile</span>vim /etc/profile<span class="token comment" spellcheck="true"># 在末尾追加</span><span class="token function">export</span> NGINX_HOME<span class="token operator">=</span>/usr/local/nginx<span class="token function">export</span> PATH<span class="token operator">=</span><span class="token variable">$PATH</span><span class="token keyword">:</span><span class="token variable">$NGINX_HOME</span>/sbin<span class="token comment" spellcheck="true"># 重新编译 /etc/profile 文件</span><span class="token function">source</span> /etc/profile</code></pre><font color="red">防坑：/usr/local/nginx 是你安装nginx的目录</font></li><li>安装验证,利用nginx -v 来查看安装是否正确，以及相关的nginx信息。<pre class=" language-bash"><code class="language-bash">nginx -v</code></pre></li><li>根据具体项目所需配置nginx.conf文件</li><li>nginx相关命令<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Nginx检测</span>nginx -t<span class="token comment" spellcheck="true"># 启动</span>nginx<span class="token comment" spellcheck="true"># 平滑重启</span>nginx -s reload<span class="token comment" spellcheck="true"># 快速停止（立即停止服务,这种方法比较强硬，无论进程是否在工作，都直接停止进程。）</span>nginx -s stop<span class="token comment" spellcheck="true"># 正常停止（从容停止服务,这种方法较stop相比就比较温和一些了，需要进程完成当前工作后再停止。）</span>nginx -s quit</code></pre></li></ol><h3 id="五、源码编译构建nginx时配置参数详细说明"><a href="#五、源码编译构建nginx时配置参数详细说明" class="headerlink" title="五、源码编译构建nginx时配置参数详细说明"></a>五、源码编译构建nginx时配置参数详细说明</h3><ol><li>在解压的目录有个文件configure，运行./configure –-help 可以看到大量的参数显示。</li><li>configure的参数分为四大类：路径相关、编译相关、依赖软件相关、模块相关<br><a href="https://myblog.erdongchen.top/2019/09/20/nginx配置浅谈-configure的参数配置说明/" title="查看详情"><strong><font color="red">configure参数配置说明书</font></strong></a></li></ol><h3 id="六、nginx-conf中的负载均衡的配置详解"><a href="#六、nginx-conf中的负载均衡的配置详解" class="headerlink" title="六、nginx.conf中的负载均衡的配置详解"></a>六、nginx.conf中的负载均衡的配置详解</h3><p>负载均衡一般配置在upstream块中，负载均衡的几种方式：</p><ol><li>轮询（默认）<br>每个请求会按时间顺序逐一分配到不同的后端服务器。在轮询中，如果服务器down掉了，会自动剔除该服务器。<font color="red">缺省配置就是轮询策略</font>。此策略适合服务器配置相当，无状态且短平快的服务使用。</li><li>weight（权重）<br>在轮询策略的基础上指定轮询的几率。权重越高分配到需要处理的请求越多。此策略可以与ip_hash和least_conn结合使用。此策略比较适合服务器的硬件配置差别比较大的情况。<br>eg：<pre><code># 动态负载均衡服务器组upstream dynamic_balance { server localhost:8080 weight=2; server localhost:8081 weight=5; server localhost:8082 weight=3;}</code></pre></li><li>ip_hash（根据ip分配）<br>指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，以保证session会话。这样每个访客都固定访问一个后端服务器，可以解决session不能跨服务器的问题。在Nginx版本1.3.1之前，不能在ip_hash中使用权重（weight）。ip_hash不能与backup同时使用。此策略适合有状态服务，比如session。当有服务器需要剔除，必须手动down掉。<br>eg:<pre><code>upstream dynamic_balance { ip_hash;    # 保证每个访客固定访问一个后端服务器 server localhost:8080 weight=2; server localhost:8081; server localhost:8082;}</code></pre></li><li>least_conn（最少连接）<br>把请求转发给连接数较少的后端服务器。轮询算法是把请求平均的转发给各个后端，使它们的负载大致相同；但是，有些请求占用的时间很长，会导致其所在的后端负载较高。这种情况下，least_conn这种方式就可以达到更好的负载均衡效果。此负载均衡策略适合请求处理时间长短不一造成服务器过载的情况。<br>eg:<pre><code>upstream dynamic_balance { least_conn;    # 把请求转发给连接数较少的后端服务器 server localhost:8080 weight=2; server localhost:8081; server localhost:8082;}</code></pre></li><li>fair（响应时间 - 第三方）<br>按后端服务器的响应时间来分配请求，响应时间短的优先分配。<br>eg:<pre><code>upstream resinserver{ server server1; server server2; fair;}</code></pre></li><li>url_hash（根据url分配 - 第三方）<br>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法<br>eg:<pre><code>upstream resinserver{ server squid1:3128; server squid2:3128; hash $request_uri; hash_method crc32;}</code></pre>参数说明：<table><thead><tr><th align="center">参数名称</th><th align="center">参数含义</th></tr></thead><tbody><tr><td align="center">fail_timeout</td><td align="center">与max_fails结合使用。</td></tr><tr><td align="center">max_fails</td><td align="center">设置在fail_timeout参数设置的时间内最大失败次数，如果在这个时间内，所有针对该服务器的请求都失败了，那么认为该服务器会被认为是停机了。</td></tr><tr><td align="center">fail_time</td><td align="center">服务器会被认为停机的时间长度，默认为10s。</td></tr><tr><td align="center">backup</td><td align="center">标记该服务器为备用服务器。当主服务器停止时，请求会被发送到它这里。</td></tr><tr><td align="center">down</td><td align="center">标记服务器永久停机了。</td></tr></tbody></table></li></ol><h3 id="七、nginx的访问权限配置"><a href="#七、nginx的访问权限配置" class="headerlink" title="七、nginx的访问权限配置"></a>七、nginx的访问权限配置</h3><ol><li>基于ip的配置<br>介绍： 访问权限可以通过配置基于ip的访问控制，达到让某些ip能够访问，限制哪些ip不能访问的效果<br><br>允许访问的配置方法<br>配置语法：allow address | CIDR | unix | all;<br>默认配置：没有配置<br>配置路径：http、server、location、limit_except下；<br><br>不允许访问的配置方法<br>配置语法：deny address | CIDR | unix | all;<br>默认配置：没有配置<br>配置路径：http、server、location、limit_except下；</li></ol><p>例子：</p><pre><code>location {    # 拒绝此IP访问    deny 192.168.1.1;    # 允许该网段访问    allow 192.168.1.0/24;    # 拒绝所有    deny all;}</code></pre><p><font color="red">从上到下开始匹配，匹配到了则停止。</font></p><ol start="2"><li>基于账号密码的配置<br>①. 安装软件httpd<pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> httpd</code></pre>②. 创建密码文件<pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># /usr/local/nginx1.16.1/mypasswd 生成密码文件的全路径</span><span class="token comment" spellcheck="true"># test 用户名</span><span class="token comment" spellcheck="true"># 123456 密码</span>htpasswd -c -b /usr/local/nginx1.16.1/mypasswd  <span class="token function">test</span>  123456</code></pre>③. 配置nginx.conf<br>需要配置的参数：<strong><font color="purple">auth_basic、auth_basic_user_file</font></strong><br>参数说明：<table><thead><tr><th align="center">参数名</th><th align="center">配置语法</th><th align="center">默认配置</th><th align="center">可配置的区域块</th></tr></thead><tbody><tr><td align="center">auth_basic</td><td align="center">string or off</td><td align="center">off</td><td align="center">http、server、location</td></tr><tr><td align="center">auth_basic_user_file</td><td align="center">密码路径</td><td align="center">/</td><td align="center">http、server、location</td></tr></tbody></table></li></ol><p>账号密码配置示例：</p><pre><code>server {    listen       80;    server_name  staticfile.erdongchen.top;    charset utf-8;    # 目录    root /usr/local/staticFiles;    #开启目录文件列表    autoindex on;    # 显示出文件的确切大小，单位是bytes    autoindex_exact_size on;    # 显示的文件时间为文件的服务器时间    autoindex_localtime on;    location /web/excelAddr/ {        # 这里是验证时的提示信息        auth_basic &quot;Please input password&quot;;        # 密码文件所在的位置        auth_basic_user_file /usr/local/mypasswd;    }    location /files_bak/ {        deny all; # 不允许访问    }    error_page   500 502 503 504  /50x.html;    location = /50x.html {        root   html;    }}</code></pre><p>④. 最终效果图<br><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20190917/authority_file.png" align="left/"></p><h4 id="附：htpasswd命令及其参数含义说明"><a href="#附：htpasswd命令及其参数含义说明" class="headerlink" title="附：htpasswd命令及其参数含义说明"></a>附：htpasswd命令及其参数含义说明</h4><p>命令：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 创建密码文件并且添加用户，</span>htpasswd -c  -b  文件名 用户名   密码<span class="token comment" spellcheck="true"># 添加用户不创建文件</span>htpasswd  -b   用户名   密码<span class="token comment" spellcheck="true"># 删除用户和密码</span>htpasswd -D  文件名   用户名<span class="token comment" spellcheck="true"># 修改密码 ：就是删除用户然后创建用户</span>htpasswd -D  文件名   用户名htpasswd  -b   用户名   密码</code></pre><p>参数含义：</p><table><thead><tr><th align="center">参数名</th><th align="center">配置语法</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">创建加密文件</td></tr><tr><td align="center">-n</td><td align="center">不更新加密文件，只将加密的用户密码显示在屏幕上</td></tr><tr><td align="center">-m</td><td align="center">默认采用MD5算法进行加密</td></tr><tr><td align="center">-d</td><td align="center">采用CRYPT算法对密码进行加密</td></tr><tr><td align="center">-p</td><td align="center">不对密码进行加密 ，即明文密码</td></tr><tr><td align="center">-s</td><td align="center">采用SHA算法对密码进行加密</td></tr><tr><td align="center">-b</td><td align="center">在命令行中一并输入用户名和密码而不是根据提示输入密码</td></tr><tr><td align="center">-D</td><td align="center">删除指定的用户</td></tr></tbody></table><h3 id="八、https的访问配置"><a href="#八、https的访问配置" class="headerlink" title="八、https的访问配置"></a>八、https的访问配置</h3><ol><li><p>查看是否有ssl模块</p><pre class=" language-bash"><code class="language-bash">nginx -V</code></pre><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20190917/qianzhi.png" align="left/"></li><li><p>如果没有上面这个就需要添加此模块：<br>nginx解压目录执行：</p><pre class=" language-bash"><code class="language-bash">./configure --with-http_ssl_module<span class="token function">make</span></code></pre><p>此时，在objs下回生成新的nginx文件，覆盖到安装目录的sbin目录下面<br><strong><font color="red">防坑：在执行完make命令后，如果不执行make install则是添加模块，就需要把新的nginx文件覆盖到安装目录的sbin目录下！！如果接着执行make install，则表示重新安装nginx！</font></strong></p></li><li><p>SSL证书申请，并放置到服务器上<br>证书申请可以在阿里云上申请或者腾讯云上也可以申请，有免费的，实在不行还可以自己创建证书；<br>阿里云申请地址：<a href="https://www.aliyun.com/product/cas" title="阿里云" target="_blank" rel="noopener"><strong><font color="purple">申请</font></strong></a></p></li><li><p>nginx.conf配置中配置SSL实现https访问<br>配置示例：</p><pre><code># http/https 静态文件访问地址server { listen       80; listen       443 ssl; server_name  staticfile.erdongchen.top; charset utf-8; # ssl证书地址 ssl_certificate     /usr/local/staticfile.pem;  # pem文件的路径 ssl_certificate_key  /usr/local/staticfile.key; # key文件的路径 # ssl验证相关配置 #缓存有效期 ssl_session_timeout  5m; #加密算法 ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; #安全链接可选的加密协议 ssl_protocols TLSv1 TLSv1.1 TLSv1.2; #使用服务器端的首选算法 ssl_prefer_server_ciphers on; # 目录 root /usr/local/staticFiles; #开启目录文件列表 autoindex on; # 显示出文件的确切大小，单位是bytes autoindex_exact_size on; # 显示的文件时间为文件的服务器时间 autoindex_localtime on; location /web/excelAddr/ {     # 这里是验证时的提示信息     auth_basic &quot;Please input password&quot;;     # 密码文件所在的位置     auth_basic_user_file /usr/local/mypassword; } location /files_bak/ {     deny all; # 不允许访问 } error_page   500 502 503 504  /50x.html; location = /50x.html {     root   html; }}</code></pre></li><li><p>访问https<br><a href="https://staticfile.erdongchen.top/" title="我的博客" target="_blank" rel="noopener"><strong><font color="purple">https://staticfile.erdongchen.top/</font></strong></a><br>此配置也可以使用http访问<br><a href="http://staticfile.erdongchen.top/" title="我的博客" target="_blank" rel="noopener"><strong><font color="purple">http://staticfile.erdongchen.top/</font></strong></a></p></li></ol><h3 id="九、新增stream模块以支持tcp代理-2019-12-03"><a href="#九、新增stream模块以支持tcp代理-2019-12-03" class="headerlink" title="九、新增stream模块以支持tcp代理(2019.12.03)"></a>九、新增stream模块以支持tcp代理(2019.12.03)</h3><p>由于个人项目上需要用到tcp代理的需求，这里记录一下通过配置nginx来实现tcp的代理转发：</p><ol><li><p>检查自己已经安装的nginx有没有支持stream模块：</p><pre class=" language-bash"><code class="language-bash">nginx -V</code></pre><p>如果在configure arguments 栏没有<code>--with-stream</code>模块，则表明nginx没有此模块；</p></li><li><p>上述命令执行的结果里面有configure arguments，把里面参数复制一份，停掉nginx，然后在nginx安装目录执行命令 </p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 备注：--with-http_ssl_module是之前带的模块（有多少模块带多少），再在后面追加--with-stream</span>./configure --with-http_ssl_module --with-stream</code></pre></li><li><p>编译完成之后，在执行<code>make</code>命令；</p></li><li><p>如果没有报错，会在nginx安装目录下的objs目录生成nginx文件，把该文件覆盖到sbin目录</p></li><li><p>配置stream模块，例如：<br>nginx.conf 主配置文件：</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20190917/9.1.png" align="left/"><p>引入的外部文件配置：</p><img style="width:85%;height:85%" src="https://staticfile.erdongchen.top/blog/blogPicture/20190917/9.2.png" align="left/"></li><li><p>文件配置完毕之后，先检查配置是否正确：<code>nginx -t</code>,在启动nginx；这时便可以使用ngixn所在的服务器ip+端口（我这里配置的是80端口），nginx会自动将请求转发到192.168.1.184的2181端口上；步骤到这里就已经配置完毕了，实现了ip+端口的方式代理tcp请求，此配置也可以实现像mysql或者redis等等的tcp转发；</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国外VPS搭建SSR教程</title>
      <link href="/2019/09/06/%E5%9B%BD%E5%A4%96VPS%E6%90%AD%E5%BB%BASSR%E6%95%99%E7%A8%8B/"/>
      <url>/2019/09/06/%E5%9B%BD%E5%A4%96VPS%E6%90%AD%E5%BB%BASSR%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程用的软件、技术和环境"><a href="#一、本篇教程用的软件、技术和环境" class="headerlink" title="一、本篇教程用的软件、技术和环境"></a>一、本篇教程用的软件、技术和环境</h3><ol><li>一台国外的vps，系统：CentOS 7.4；</li><li>ssh连接工具Xshell；</li><li>Shadowsocks客户端； </li></ol><h3 id="二、ssh连接到vps"><a href="#二、ssh连接到vps" class="headerlink" title="二、ssh连接到vps"></a>二、ssh连接到vps</h3><p>利用客户端软件（Xshell、Putty、SecureCRT等等）远程连接到你的国外vps。</p><h3 id="三、vps上跑脚本命令"><a href="#三、vps上跑脚本命令" class="headerlink" title="三、vps上跑脚本命令"></a>三、vps上跑脚本命令</h3><ol><li>在命令行内输入如下：</li></ol><pre class=" language-bash"><code class="language-bash">yum -y <span class="token function">install</span> <span class="token function">wget</span><span class="token function">wget</span> -N --no-check-certificate https://raw.githubusercontent.com/CecilWu/SSR-Chinese/master/ssr.sh <span class="token operator">&amp;&amp;</span> <span class="token function">chmod</span> +x ssr.sh <span class="token operator">&amp;&amp;</span> <span class="token function">bash</span> ssr.sh</code></pre><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/1.jpg" align="left/">此时服务器会自动安装脚本，如果脚本执行过程中没有反映，你直接回车确认即可。安装完毕后如下图所示：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/2.jpg" align="left/">2. 输入数字1后回车安装ShadowsocksR。安装完毕后会要求你自定义端口和密码。然后回车确认，他会要求你选择加密方式，此时一般选10：aes-256-cfb。如下图所示：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/3.jpg" align="left/">3. 然后按照下图设置协议插件、混淆插件。<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/4.jpg" align="left/">4. 配置设备数、端口限速<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/5.jpg" align="left/">5. 过段时间之后，系统会提示安装完成，同时显示SS账号的配置信息，自己保存好即可！<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/6.jpg" align="left/"><h3 id="四、安装第二个账号"><a href="#四、安装第二个账号" class="headerlink" title="四、安装第二个账号"></a>四、安装第二个账号</h3><p>如果你想返回主界面继续安装第二个帐号，可以输入下面的命令调出，然后选择“9”切换到多端口模式即可:</p><pre class=" language-bash"><code class="language-bash"><span class="token function">bash</span> ssr.sh</code></pre><p>·<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/7.jpg" align="left/"></p><h3 id="五、Shadowsocks客户端下载与配置"><a href="#五、Shadowsocks客户端下载与配置" class="headerlink" title="五、Shadowsocks客户端下载与配置"></a>五、Shadowsocks客户端下载与配置</h3><p><a href="https://github.com/shadowsocks/shadowsocks-windows/releases/download/4.1.7.1/Shadowsocks-4.1.7.1.zip" title="点击下载" target="_blank" rel="noopener"><strong><font color="purple">Shadowsocks客户端下载地址</font></strong></a><br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/8.jpg" align="left/"><br>开启后即可愉快地玩耍了！<br><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190906/9.jpg" align="left/"></p>]]></content>
      
      
      <categories>
          
          <category> 其他教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 技术 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大数据教程(一)-基础配置</title>
      <link href="/2019/08/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%B8%80)-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/08/29/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%95%99%E7%A8%8B(%E4%B8%80)-%E5%9F%BA%E7%A1%80%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="一、本篇教程侧重点导读"><a href="#一、本篇教程侧重点导读" class="headerlink" title="一、本篇教程侧重点导读"></a>一、本篇教程侧重点导读</h3><ol><li>使用VMware虚拟出几台服务器后对网络的配置，主要是为了连通物理本机和虚拟服务器；（VMware的安装，虚拟服务器比较简单，这里不再赘述）</li><li>服务器之间配置ssh免密登陆；</li><li>修改主机名以及host配置；</li><li>JDK的安装配置；</li><li>追加配置的说明；</li></ol><h3 id="二、本篇教程用的软件、技术和说明"><a href="#二、本篇教程用的软件、技术和说明" class="headerlink" title="二、本篇教程用的软件、技术和说明"></a>二、本篇教程用的软件、技术和说明</h3><ol><li>虚拟机软件VMware（如果你有几台比较好的服务器就不需要这个软件了）；</li><li>使用JDK版本：1.8.0_161；</li><li>使用到linux系统：CentOS 7.2；</li></ol><h3 id="三、服务器的网络配置"><a href="#三、服务器的网络配置" class="headerlink" title="三、服务器的网络配置"></a>三、服务器的网络配置</h3><ol><li><p>安装完VMware后，会在物理本机上多出两块虚拟网卡（VMnet1、VMnet8），一会我们需要对VMnet8配置一下；</p></li><li><p>用VMware虚拟出一台服务器之后，启动服务器后，使用命令<code>ifconfig</code>会看到有一块网卡（比如说我的就叫eth0），然后把名字记下来，在<code>/etc/sysconfig/netword-scripts</code>目录下找到这块网卡文件（linux里面万物皆文件）：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/networkCard_update.png" align="left/">将其修改配置如下（网段可自定义）：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/networkCard_configure.png" align="left/"></li><li><p>配置完毕之后重启网络<code>service network restart</code><br><strong><font color="red">防坑：如果网卡重启失败，把网卡文件（我的是ifcfg-eth0）中的mac配置（HWADDR=xx:xx:xx:xx）项删除，再删除网卡相关信息文件<code>/etc/udev/rules.d/70-persistent-net.rules</code>,最后重启服务器<code>reboot</code></font></strong><br>至此，linux服务器配置完毕，在配置VMware的虚拟网络配置！</p></li><li><p>打开：VMware &gt; 编辑 &gt; 虚拟网络编辑器；修改名字为VMnet8的那块网卡，将子网ip改为广播地址：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/ipaddr_update.png" align="left/">点击应用之后，VMware会自动将`192.168.6.1`配置成为你的物理机VMnet8的那块网卡，将`192.168.6.2`作为网关地址，如下两图：<img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/localhost_explain.png" align="left/"><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/look_default_gateway.png" align="left/"><p><strong><font color="green">启动服务器之后查看ip地址时就是你在ifcfg-eth0文件中配置的ip地址，并且可以从物理机（192.168.6.1）ping通你的服务器（192.168.6.101），此时第一台虚拟机配置完成，你可以使用VMware自带的克隆功能多克隆几台服务器，需要注意的是：克隆出来的服务器的ip地址、mac地址和被克隆的服务器会冲突，需要重新修改一下</font></strong></p></li><li><p>重新生成克隆出来的每一台服务器的mac地址：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/createMAC.png" align="left/"></li><li><p>启动每一台克隆出来的服务器并且修改其ip地址：打开<code>/etc/sysconfig/netword-scripts/ifcfg-eth0</code>文件 将IPADDR 修改成新的ip地址并重启；<br>到此，所有服务器的网络配置完成！</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/network_completed.png" align="left/"></li></ol><h3 id="四、修改主机名、配置host"><a href="#四、修改主机名、配置host" class="headerlink" title="四、修改主机名、配置host"></a>四、修改主机名、配置host</h3><ol><li><p>主机名：修改每一台机器上的配置文件<code>/etc/hostname</code>，并重启；</p></li><li><p>配置域名：修改<code>192.168.6.100</code>机器上面配置文件：<code>/etc/hosts</code>,修改完成后，如图所示：</p><img style="width:85%;height:85%" src="http://staticfile.erdongchen.top/blog/blogPicture/20190829/hosts_update.png" align="left/"><p><strong><font color="green">配置域名的作用是：在后面学习大数据的时候，会频繁使用到各个服务器的ip地址，配置成域名之后方面管理和记忆</font></strong></p></li><li><p>将100上面的hosts文件覆盖到其他机器上面：<code>scp hosts root@192.168.6.101:/etc/</code><br><strong><font color="red">说明：<br>在后面博客中将称<code>192.168.6.100</code>为<code>master</code><br>在后面博客中将称<code>192.168.6.101</code>为<code>slave1</code><br>在后面博客中将称<code>192.168.6.102</code>为<code>slave2</code><br>在后面博客中将称<code>192.168.6.103</code>为<code>slave3</code><br>在后面博客中将称<code>192.168.6.104</code>为<code>slave4</code><br></font></strong></p></li></ol><h3 id="五、ssh免密登陆"><a href="#五、ssh免密登陆" class="headerlink" title="五、ssh免密登陆"></a>五、ssh免密登陆</h3><ol><li><p>在master上输入：<code>ssh-keygen -t rsa -b 4096</code>，此时会在当前登录用户家目录下生成.ssh文件夹,里面会有一对秘钥，查看命令<code>ll ~/.ssh</code>；</p><p><strong><font color="green">参数说明：<br>-t type 指定要创建的密钥类型。可以使用：”rsa1”(SSH-1) “rsa”(SSH-2) “dsa”(SSH-2)<br>-b bits 指定密钥长度。对于RSA密钥，最小要求768位，默认是2048位。DSA密钥必须恰好是1024位(FIPS 186-2 标准的要求)。</font></strong></p></li><li><p>接着输入<code>ssh-copy-id -i ~/.ssh/id_rsa.pub root@slave1</code>，这时会让你输入slave1的root账号密码，这句命令的效果是将刚刚生成的id_rsa.pub里面的信息追加到101服务器上/root/.ssh目录下的authorized_keys文件中；</p><p><strong><font color="green">这时就可以从master免密登录到slave1上了：<code>ssh root@slave1</code> </font></strong><br><strong><font color="red">注意：如果还需要从slave1免密登录到master，则需要在slave1服务器上执行第1和2两步</font></strong><br>你还可以将所有的服务器配置成互为免密登录，配置成互为免密登录之后，方便后面学习大数据的时候少踩坑；<br>后面在hdfs集群启动的时候，还需要将自己和自己配置成免密登录，不然会有问题。</p></li></ol><h3 id="六、JDK的安装配置"><a href="#六、JDK的安装配置" class="headerlink" title="六、JDK的安装配置"></a>六、JDK的安装配置</h3><ol><li><p>将事先准备好的jdk的tar.gz包上传到master上解压：<code>tar -xzvf jdk-8u161-linux-x64.tar.gz -C /usr/local/</code></p><p><strong><font color="green">-C 解压文件到指定的目录 </font></strong></p></li><li><p>编辑配置环境变量<code>vim /etc/profile</code>,添加如下配置：</p><pre class=" language-java"><code class="language-java">JAVA_HOME<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>local<span class="token operator">/</span>jdk1<span class="token number">.8</span><span class="token punctuation">.</span>0_161CLASSPATH<span class="token operator">=</span>$JAVA_HOME<span class="token operator">/</span>lib<span class="token operator">/</span>PATH<span class="token operator">=</span>$PATH<span class="token operator">:</span>$JAVA_HOME<span class="token operator">/</span>binexport PATH JAVA_HOME CLASSPATH</code></pre></li><li><p>执行命令 ：<code>source /etc/profile</code></p></li><li><p>查看安装情况<code>java -version</code></p><p><strong><font color="red">JDK在每台机器上都需要安装！</font></strong></p></li></ol><h3 id="七、追加配置的说明（2019-11-27）"><a href="#七、追加配置的说明（2019-11-27）" class="headerlink" title="七、追加配置的说明（2019.11.27）"></a>七、追加配置的说明（2019.11.27）</h3><p> 由于后面要建立完成的大数据平台，所以追加本节内容，用于说明后面搭建的集群规划</p><ol><li>新增了一台服务器<code>192.168.6.105</code>和前面服务器一样需要配置免密、JDK等基础配置；</li><li>集群规划：<table><thead><tr><th align="center">主机名</th><th align="center">IP</th><th align="center">安装的软件</th><th align="center">运行的进程</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">192.168.6.100</td><td align="center">jdk、hadoop</td><td align="center">NameNode、DFSZKFailoverController(zkfc)</td></tr><tr><td align="center">slave1</td><td align="center">192.168.6.101</td><td align="center">jdk、hadoop</td><td align="center">NameNode、DFSZKFailoverController(zkfc)、ResourceManager</td></tr><tr><td align="center">slave2</td><td align="center">192.168.6.102</td><td align="center">jdk、hadoop</td><td align="center">ResourceManager</td></tr><tr><td align="center">slave3</td><td align="center">192.168.6.103</td><td align="center">jdk、hadoop、zookeeper</td><td align="center">DataNode、NodeManager、JournalNode、QuorumPeerMain</td></tr><tr><td align="center">slave4</td><td align="center">192.168.6.104</td><td align="center">jdk、hadoop、zookeeper</td><td align="center">DataNode、NodeManager、JournalNode、QuorumPeerMain</td></tr><tr><td align="center">slave5</td><td align="center">192.168.6.105</td><td align="center">jdk、hadoop、zookeeper</td><td align="center">DataNode、NodeManager、JournalNode、QuorumPeerMain</td></tr></tbody></table></li></ol>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 技术 </tag>
            
            <tag> 环境配置 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开通博客的第一天干嘛？当然是手把手教你如何搭建博客啦！</title>
      <link href="/2019/08/15/howToCreateBlog/"/>
      <url>/2019/08/15/howToCreateBlog/</url>
      
        <content type="html"><![CDATA[<h3 id="本套博客搭建教程的前置条件："><a href="#本套博客搭建教程的前置条件：" class="headerlink" title="本套博客搭建教程的前置条件："></a>本套博客搭建教程的前置条件：</h3><ol><li>域名一个；</li><li>github账号一个；</li><li>本机已安装node.js；</li><li>本机已安装git，并且本地仓库已关联到自己github上的一个repository，且repository的名字必须为‘你的github账号.github.io’</li></ol><h3 id="下面进入本教程："><a href="#下面进入本教程：" class="headerlink" title="下面进入本教程："></a>下面进入本教程：</h3><p><strong>基础部分</strong></p><ol><li>切换国内源  <code>npm config set registry=&quot;http://registry.cnpmjs.org&quot;</code></li><li>安装hexo  <code>npm install -g hexo</code></li><li>初始化Hexo  <code>hexo init</code></li><li>安装必要的模块  <code>npm install</code></li><li>生成静态文件  <code>hexo g  或者  hexo generate</code></li><li>本地测试（浏览器查看：<a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a>）  <code>hexo s  或者  hexo server</code></li></ol><p><strong>个性化设置</strong></p><ol><li><p>hexo配置文件修改，在根目录下（执行hexo init的那个目录）会有一个_config.yml的配置文件，修改如下内容：</p><pre class=" language-java"><code class="language-java"># Hexo Configuration# Docs<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>docs<span class="token operator">/</span>configuration<span class="token punctuation">.</span>html# Source<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>hexojs<span class="token operator">/</span>hexo<span class="token operator">/</span>Sitetitle<span class="token operator">:</span> 换成你的主页标题subtitle<span class="token operator">:</span> 主页副标题description<span class="token operator">:</span> 主页介绍的一句话author<span class="token operator">:</span> 你的名字language<span class="token operator">:</span> zh<span class="token operator">-</span>CN #语言timezone<span class="token operator">:</span> Asia<span class="token operator">/</span>Shanghai #时区##    # URL#    ## If your site is put in a subdirectory<span class="token punctuation">,</span>#    ##set url as <span class="token string">'http://yoursite.com/child'</span> and root as <span class="token string">'/child/'</span>#    # 更换域名是需要配置的参数url<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>voidking<span class="token punctuation">.</span>comroot<span class="token operator">:</span> <span class="token operator">/</span>##    # Extensions#    ## Plugins<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>plugins<span class="token operator">/</span>#    ## Themes<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>themes<span class="token operator">/</span>theme<span class="token operator">:</span> 你用的主题文件夹名字 # themes下的文件##    # Deployment#    ## Docs<span class="token operator">:</span> http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>hexo<span class="token punctuation">.</span>io<span class="token operator">/</span>docs<span class="token operator">/</span>deployment<span class="token punctuation">.</span>htmldeploy<span class="token operator">:</span>    type<span class="token operator">:</span> git    # GitHub仓库地址，此地址一定要是前置条件第四条的那个地址    # 地址格式：https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>你的github账号<span class="token operator">/</span>你的github账号<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git    # 例如    repository<span class="token operator">:</span> https<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>github<span class="token punctuation">.</span>com<span class="token operator">/</span>a878804506<span class="token operator">/</span>a878804506<span class="token punctuation">.</span>github<span class="token punctuation">.</span>io<span class="token punctuation">.</span>git    branch<span class="token operator">:</span> master</code></pre><p><strong><font color="red">防坑：_config.yml配置参数时，注意冒号后面一定要有一个空格</font></strong></p></li><li><p>修改主题<br>找一个自己喜欢的主题，然后clone到hexo根目录下的themes目录下<br>eg：切换到根目录下文件下，cmd执行<br><code>git clone -b master https://github.com/lewis-geek/hexo-theme-Aath.git themes/aath</code><br>下载好后，你在_config.yml（主题是根目录下的）中的theme:处配置成你下在的主题名字（就是下载的主题文件夹名字 ）</p></li><li><p>上传的github上（会上传到前置条件第四条的那个地址下）<br>如果想把原来的清除 <code>hexo clean</code><br>重新生成静态文件 <code>hexo g</code><br>上传到提交文件 <code>hexo d</code><br>此时就可以用浏览器访问前置条件第四条的那个地址，会就出现你的博客首页</p></li></ol><p><strong>附加:域名配置</strong></p><ol><li>到你域名提供商那里配置域名解析规则,记录类型为：CNAME</li><li>记录值为：前置条件第四条的那个地址</li><li>Hexo根目录下会有一个source目录，在source下新建一个CNAME文件，文件内容是你刚刚配置好的域名</li><li>再次修改Hexo根目录下的_config.yml配置文件，填写url</li><li>再次执行打包上传命令 <code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</code><br><strong><font color="red">防坑：域名访问404，但是xxx.github.io能访问，那就说明还是你的域名配置有问题，仔细检查</font></strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 其他教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 环境搭建 </tag>
            
            <tag> 技术 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
